<p align="justify"> <strong>Autor: </strong> Rogério Júnior </p>
<p align="justify"> <strong>Fonte: </strong> <a href="noic.com.br">Noic</a> </p>

<h1>2.3 - STL++</h1>

<h3>Vetor Dinâmico</h3>
<p align="justify">Outra estrutura já implementada é o <strong>vector</strong>. Ele está na biblioteca <strong>vector</strong> e representa um vetor dinâmico, ou seja, não precisamos especificar quantos elementos ele irá guardar. Para declará-lo, usamos um comando semelhante ao do <strong>set</strong>. Para declararmos um <strong>vector</strong> de nome <strong>vetor</strong> que irá guardar elementos do tipo <strong>int</strong>, por exemplo, uso o comando "<strong>vector&lt;int&gt; vetor;</strong>". Ele pode ter suas posições acessadas como um vetor normal, com os operadores "[]", mas apenas se a posição desejada já tiver sido inserida. Ele tem uma função importante chamada <strong>push_back(x)</strong>, que insere um elemento no fim do vetor em <strong>O(1)</strong>. Assim, só podemos acessar a posição <strong>n</strong> do vetor se já tivermos inserido <strong>n+1 </strong>elementos (pois ele começa da posição 0). Algumas outras funções interessantes do <strong>vector </strong>são:</p>
<p align="justify"><strong>pop_back() </strong>- apaga o <p align="justify"> elemento do vetor</p>
<p align="justify"><strong>size()</strong> - retorna, em <strong>O(1)</strong>, o tamanho do vetor</p>
<p align="justify"><strong>back() </strong>- retorna, em <b>O(1)</b>, o <p align="justify"> elemento do vetor</p>
<p align="justify"><strong>front() </strong>- retorna, em <strong>O(1), </strong>o primeiro elemento do vetor</p>
<p align="justify"><strong>clear() </strong>- apaga, em <strong>O(size)</strong>, todos os elementos do vetor</p>
<p align="justify"><strong>begin() </strong>- retorna, em <strong>O(1)</strong>,<strong> </strong>um ponteiro para o primeiro elemento do vetor</p>
<p align="justify"><strong>end()</strong> - retorna,  em <strong>O(1)</strong>, um ponteiro para o fim do vetor</p>
<p align="justify">As duas últimas funções são bem úteis como parâmetros para o <strong>sort</strong>, por exemplo. Segue, para melhor compreensão, o código de um programa que recebe <strong>n</strong> inteiros e os imprime ordenadamente, usando um <strong>vector</strong> e um <strong>sort</strong>:</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/6a02a64a7b19cd1605cb.js"></script></p>
<p align="justify">Lembre-se que o vetor normal (estático) é sempre mais rápido que um vetor dinâmico, e tem bem menos risco de acessar uma posição inválida (pois no começo declaramos seu tamanho). A vantagem do <strong>vector </strong>está puramente na organização do código e na implementação de suas funções, mas não fique viciado em usá-lo. Se não for extremamente complicado, use um vetor estático.</p>
<p align="justify"><b>String de C++</b></p>
<p align="justify">Já foi citado nesse curso que <strong>string</strong> refere-se a uma certa estrutura de C++, que está na biblioteca <strong>string</strong>, que tenta imitar o vetor de <strong>char</strong>. Ela é como um vetor dinâmico de <strong>char</strong>. A partir de agora, no curso, <strong>string </strong>sempre irá se referir a essa estrutura de C++ e o vetor de <strong>char </strong>pode ser referido como <strong>cstring</strong>. O diferencial dessa estrutura em relação à <strong>cstring</strong> é um conjunto de funções e operadores que facilitam muito nossa vida, com um certo custo de tempo. Primeiro, para declará-la, não preciso informar seu tamanho: para criarmos uma <strong>string</strong> de nome <strong>frase</strong> basta o comando "<strong>string frase;</strong>". A comparação entre duas <strong>strings</strong> é feita com os operadores "&lt;", "&gt;", "&lt;=", "&gt;=" e "==". Se temos a <strong>string frase1 </strong>e<strong> </strong>a <strong>string frase2</strong>, então <strong>frase1&lt;frase2</strong> indica que, em ordem alfabética<strong> frase1</strong> vem antes de <strong>frase</strong><strong>2</strong>, e todos os outros operadores são definidos de maneira análoga. Podemos também somar duas <strong>strings</strong> com o operador "+", de modo a <a href="http://pt.wikipedia.org/wiki/Concatena%C3%A7%C3%A3o" onclick="_gaq.push(['_trackEvent', 'outbound-article', 'http://pt.wikipedia.org/wiki/Concatena%C3%A7%C3%A3o', 'concatená-las']);" title="concatenação - wikipedia"  target="_blank">concatená-las</a>, ou seja, se somarmos as duas <strong>strings </strong>"earth" e "quake", com o comando "earth"+"quake", teremos a <strong>string </strong>"earthquake". Ela também reconhece o operador "+=" de maneira semelhante, ou seja, se declaramos "<strong>string frase="earth";</strong>" e executarmos o comando "<strong>frase+="quake";</strong>", então <strong>frase</strong> estará guardando agora a <strong>string </strong>"earthquake". O melhor é que podemos somar uma <strong>cstring </strong>ou um <strong>char </strong>a uma <strong>string</strong> também, usando os mesmos operadores, ou até atribuir-lhe o valor de uma <strong>cstring </strong>ou <strong>char</strong> com o operador "=". Assim como na <strong>cstring</strong>, podemos acessar a posição <strong>n</strong> com os operadores "[]" (se tal posição existir).</p>
<br />
<p align="justify">Infelizmente, nada é perfeito, e não podemos escanear uma <strong>string </strong>usando a função <strong>scanf</strong>, ou imprimir usando a <strong>printf</strong>. Temos então que usar as funções <strong>cin </strong>e <strong>cout</strong>, da biblioteca <b>iostream</b>, do C++. Elas são bem mais simples de usar que as que estamos acostumados, mas isso tem o custo de serem bem mais lentas, só devendo serem utilizadas nesse caso (ler uma <strong>string</strong>), pois podem gerar Time Limit Exceeded em casos de entradas muito grandes. Para ler objetos com <strong>cin</strong>, basta chamarmos ela e, para cada objeto <strong>x</strong> que vamos ler, escrever o comando<strong> " &gt;&gt; x </strong>", e terminar a função com ";". Se quisermos ler, por exemplo, dois inteiros e salvá-los, respectivamente nas variáveis <strong>int a </strong>e <strong>int b</strong>, usamos o comando "<strong>cin &gt;&gt; a &gt;&gt; b;</strong>". Note que não temos que determinar os tipos dos objetos que serão lidos, a função faz isso sozinha, o que a faz gastar mais tempo. Para imprimir, usamos a <strong>cout</strong>, de maneira análoga, mas agora com o operador "&lt;&lt;". Para imprimirmos, por exemplo, a frase "o valor eh ", seguida de um inteiro salvo em <strong>int x</strong>, e de uma quebra de linha, usamos o comando "<strong>cout &lt;&lt; "o valor eh " &lt;&lt; x &lt;&lt; '\n';</strong>". Vale lembrar que quando o <strong>cin</strong> lê uma <strong>string</strong>, ele lê a entrada até o primeiro espaço ou quebra de linha. Se quisermos usar os truques da <strong>scanf</strong> para escolhermos o que queremos ler, devemos ler uma <strong>cstring</strong> e depois salvá-la em uma <strong>string</strong>. Para lermos uma linha toda por exemplo, e a salvarmos na <strong>string frase</strong>, primeiro declaramos a <strong>string frase</strong>, depois um vetor de char auxiliar, "<strong>char aux[30];</strong>", por exemplo. Feito isso, lemos a linha toda e a salvamos em <strong>aux</strong>, com o comando visto na primeira aula "<strong>scanf(" %[^\n]", aux);</strong>" e fazemos <strong>frase </strong>receber o valor de <strong>aux </strong>com o comando "<strong>frase=aux;</strong>". Podemos sempre ler uma <strong>cstring</strong> e depois atribuir seu valor a uma <strong>string</strong>, mas é mais simples usar <strong>cin</strong>.</p>
<br />
<p align="justify">Além disso, a <strong>string </strong>tem várias funções interessantes, que podem ser vistas na <a href="http://www.cplusplus.com/reference/string/string/" onclick="_gaq.push(['_trackEvent', 'outbound-article', 'http://www.cplusplus.com/reference/string/string/', 'referência do Cplusplus']);" title="string - cplusplus"  target="_blank">referência do Cplusplus</a>, mas, dentre elas, as mais importantes são:</p>
<p align="justify"><strong>size()</strong> - retorna o tamanho da <strong>string </strong>em <strong>O(1)</strong>.</p>
<p align="justify"><strong>substr(int pos, int tam) </strong>- retorna, em <strong>O(tam)</strong>, a substring formada pelos <strong>tam </strong>caracteres partir da posição <strong>pos</strong>. Se omitirmos o segundo parâmetro, a função retorna a subtring formada por todos os caracteres da <strong>string</strong> a partir da posição <strong>pos</strong>.</p>
<p align="justify">Segue de exemplo um código que lê uma <strong>string</strong>, imprime seu tamanho e depois a imprime sem as duas primeiras letras:</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/41526c406ffaebc7e3d6.js"></script></p>
<p align="justify">Tal programa, ao receber como entrada o exemplo:</p>
<p align="justify">NOIC</p>
<p align="justify">deveria gerar a saída:</p>
<p align="justify">4 IC</p>

