<p align="justify"> <strong>Autor: </strong> Rogério Júnior </p>
<p align="justify"> <strong>Fonte: </strong> <a href="noic.com.br">Noic</a> </p>

<h1>3.2 - Guloso</h1>

<p align="justify">Imagine o seguinte problema: você é o dono de uma grande rede de postos de gasolina e, ao final do mês, você renova seu estoque. Nesse dia, o setor de pesquisa da sua empresa lhe envia uma lista com os preços e estoques dos seus maiores fornecedores. A primeira linha da lista tem um inteiros <strong>n </strong>e um decimal<strong> </strong><strong>d</strong>, o número de fornecedores e a demanda do mercado, respectivamente. Cada uma das próximas <strong>n</strong> linhas tem dois decimais: <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_eca91c83a74a2373ca5f796700e99fd3.gif' style='vertical-align: middle; border: none; ' class='tex' alt="p_i" /></span><script type='math/tex'>p_i</script> e <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_8dec559e201a7b6a0f99baeaa1731051.gif' style='vertical-align: middle; border: none; ' class='tex' alt="e_i" /></span><script type='math/tex'>e_i</script>, respectivamente. Na i-ésima linha, <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_eca91c83a74a2373ca5f796700e99fd3.gif' style='vertical-align: middle; border: none; ' class='tex' alt="p_i" /></span><script type='math/tex'>p_i</script> é o preço do litro de gasolina no fornecedor <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_865c0c0b4ab0e063e5caa3387c1a8741.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="i" /></span><script type='math/tex'>i</script> e <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_eca91c83a74a2373ca5f796700e99fd3.gif' style='vertical-align: middle; border: none; ' class='tex' alt="p_i" /></span><script type='math/tex'>p_i</script> é o estoque desse fornecedor em litros. Você deseja comprar exatamente a demanda que precisa (para que seu lucro seja máximo pela lei da oferta e da procura), então faça um programa que calcule quanto dinheiro você irá gastar nessa compra de modo que o custo seja mínimo, e imprima esse valor com precisão de duas casas decimais. Se não houver estoque suficiente no mercado para a sua compra, imprima uma única linha com a palavra "Impossivel".</p>
<br />
<p align="justify">A primeira ideia que podemos ter é ordenar os fornecedores pelos preços de seus combustíveis, do menor para o maior comprar o máximo possível do fornecedor mais barato e então passarmos para o fornecedor seguinte (o próximo mais barato) até que tenhamos comprado toda a demanda necessária. Felizmente essa ideia realmente funciona e é eficiente! Ela funciona porque se terminarmos as compras e sobrar gasolina em um fornecedor A que é mais barato que algum fornecedor B em que você comprou, o preço final teria sido menor se você tivesse comprado a gasolina de A ao invés da de B. Ordenar os fornecedores pelo preço da gasolina custa <strong>O(n*log n)</strong>, e percorrer o vetor comprando  a gasolina leva <strong>O(n)</strong>. Assim a complexidade fica <strong>O(n*(log n+1)) </strong><span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_fb4f353ef9a72c24566678c957a5ae9f.gif' style='vertical-align: middle; border: none; padding-bottom:2px;' class='tex' alt="\approx" /></span><script type='math/tex'>\approx</script> <b>O(n*log n)</b>, para <strong>n </strong>grande.</p>
<br />
<p align="justify">Para facilitar o código, criei a <strong>struct gas</strong>, que guarda duas <strong>doubles</strong>: <strong>preco</strong> e <strong>estoq</strong>, representando um fornecedor. Depois crio o array de <strong>gas</strong> de nome <strong>forn</strong> para representar a lista de fornecedores que você recebeu do setor de pesquisa, e é esse array que vou ordenar com o <strong>sort</strong> e a função <strong>compara</strong>, que faz a comparação entre dois <strong>gas</strong> pelos valores de suas variáveis <strong>preco</strong>. Ao percorrer o vetor, vou comprando a gasolina mais barata sempre e guardando o valor gasto na variável <strong>custo</strong>. No final, imprimo o valor gasto com precisão de duas casas decimais<strong> </strong>Segue o código para melhor entendimento:</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/c477094e61908cfbdfda.js"></script></p>
<p align="justify">Este programa resume muito bem a ideia de um algoritmo guloso: é aquele em que temos que fazer algumas escolhas, então ordeno as opções usando o critério de comparação que parece o melhor possível para a escolha desejada, e depois vou escolhendo as melhores opções até que tenha feito tudo o que preciso. No caso, tenho que escolher de quais fornecedores comprar, então ordeno as opções pelo critério preço, pois o melhor fornecedor é o mais barato, e vou comprando sempre do melhor até que tenha atingido a demanda necessária.</p>
<br />
<p align="justify">Um programa que vai procurando as melhores opções no momento, é um programa guloso, e este tipo de algoritmo resolve muitos problemas. O problema mais difícil que já caiu na PJ pode ter sido o Dentista, da OBI 2010. Agora que você já sabe como implementar um algoritmo guloso, clique <a href="http://olimpiada.ic.unicamp.br/pratique/programacao/nivelj/2010f2pj_dentista" onclick="_gaq.push(['_trackEvent', 'outbound-article', 'http://olimpiada.ic.unicamp.br/pratique/programacao/nivelj/2010f2pj_dentista', 'aqui']);" title="Dentista"  target="_blank">aqui</a> para tentar resolvê-lo. Se você não conseguir, seguem a resposta e o código comentado, mas realmente tente fazê-lo sozinho antes de os ler.</p>
<br />
<p align="justify">O dentista quer sempre atender à consulta que conflitua com o menor número de consultas que ele ainda pode pegar. Como ordenar, então as escolhas? Parece bem atrativo escolhermos sempre as consultas de menor duração que não conflituam com as já escolhidas, mas veja o seguinte caso: tenho uma consulta que começa às 9 e termina às 12 (três horas de duração), uma que começa às 11 e termina às 13 (duas horas de duração) e uma que começa às 12 e termina às 15 (três horas de duração). Note que é melhor escolher as duas consultas mais longas do que escolher a curta, pois elas são conflitantes. Ponha-se então no lugar do dentista: você acabou de atender um paciente e na sala de espera estão todas as pessoas cujo horário do começo da consulta ainda não passou, qual delas você atenderia? A que termina primeiro! Qualquer outra consulta que termine um pouco mais tarde pode acabar conflituando com alguma outra que você poderia atender se tivesse pego a consulta que termina mais cedo! Assim, faremos um guloso que ordena as consultas por fim e vamos sempre atender a consulta (que ainda pode ser atendida, ou seja, que não passou ainda o horário do começo) que termina mais cedo.</p>
<br />
<p align="justify">Vamos criar a <strong>struct compromisso</strong>, que guarda os inteiros <strong>ini </strong>e <strong>fim</strong>. Vamos criar um vetor de <strong>compromissos</strong> de nome <strong>consulta</strong> e, em cada um de seus elementos, guardar os horários de início e fim de cada consulta. Vamos ordenar o vetor pelo valor de <strong>fim</strong> de cada elemento e percorrê-lo guardando em <strong>livre</strong>, o horário em que o dentista já poderá atender o próximo cliente. No começo, <strong>livre </strong>será zero. Percorrendo o vetor, para cada elemento olharemos se podemos atender a consulta (se seu começo é depois de <strong>livre</strong>). Se pudermos, adicionamos um a <strong>qtd</strong>, que guardará o número de consultas atendidas, e faremos <strong>livre</strong> receber o fim da consulta que estamos verificando. Segue o código para melhor entendimento:</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/438a005168adcf3c1b26.js"></script></p>
<p align="justify">Novamente, temos a implementação geral de um algoritmo guloso: tenho que fazer um conjunto de escolhas; crio um critério de ordenação para elas, que decide qual a melhor a ser tomada; ordeno as escolhas por esse critério; percorro as possíveis escolhas, da melhor para a pior, sempre escolhendo as possíveis, com prioridade para as melhores, até já ter atingido meu objetivo.</p>

