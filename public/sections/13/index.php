<h1> 3.5 - Programação Dinâmica</h1>

<p align="justify"> <strong>Autor: </strong> Rogério Júnior </p>
<p align="justify"> <strong>Fonte: </strong> <a href="noic.com.br">Noic</a> </p>
<br />
<p align="justify">Na <a title="Aula 4 - Funções" href="http://noic.com.br/informatica/curso-noic-de-informatica/aula-4-funcoes/" target="_blank">aula de funções</a> vimos como calcular o <strong>n</strong>-ésimo número da sequência de Fibonacci. Foi mostrada, também, a árvore de recursão de calcular o 5º núumero da sequência de Fibonacci, que mostra todas as chamadas que temos que fazer dessa função. Reveja: <a href="http://noic.com.br/wp-content/uploads/2015/04/fib.png"><img class="aligncenter size-full wp-image-3491" src="http://noic.com.br/wp-content/uploads/2015/04/fib.png" alt="fib" width="688" height="409" /></a>Note que o Fib(2), por exemplo, é recalculado 3 vezes na árvore, o que gera o recálculo, para cada chamada do Fib(2) de dois outros valores: Fib(0) e Fib(1). Percebe como sempre chamar a recursão é ineficiente? O número de chamadas em uma função que calcula o Fibonacci cresce exponencialmente e, se formos calcular o Fib de números maiores que 60, já levamos TLE na maioria dos corretores. Imagine uma chamada de Fib que teria que recalcular o valor de Fib(5): ele teria que chamar, novamente, todas os 14 valores de Fib mostrados na árvore acima, mas, e se salvarmos o valor de Fib(5) em algum lugar, depois que o calcularmos? Assim, da próxima vez que precisássemos do valor de Fib(5), teríamos ele guardado sem termo que chamar nenhuma outra função, acessando-o em O(1)! Bastava que guardássemos uma variável com o valor de Fib(5), começando com 0, por exemplo e, quando fôssemos chamar a função, iríamos verificar se o valor lá salvo ainda é zero. Se fosse, então ainda não calculamos esse valor, mas assim que terminássemos, iríamos trocar o valor de da variável de 0 para o valor de Fib(5), fazendo com que das próximas vezes, bastasse retornar o valor lá salvo. Mas por quê fazer isso só com 5?</p>
<br />
<p align="justify">A ideia de Programação Dinâmica (ou Dynamic Programming (DP), em inglês) é evitar o recálculo de uma função para os mesmos parâmetros que já calculamos alguma vez, salvando todos os resultados que já obtemos até então, calculando o valor da função apenas se ele nunca foi calculado. Assim, só calculamos cada valor da função uma única vez! Chamamos de estado da DP um conjunto de parâmetros que define a situação que ela precisa calcular, e se ela passar pelo mesmo estado duas vezes, ela só precisa calcular seu valor uma vez e guardá-lo para o futuro, se ela precisar. No caso, os possíveis estados da DP são as possíveis posições da sequência que ela quer calcular.</p>
<br />
<p align="justify">Vamos tentar refazer a função que calcula o n-ésimo termo da sequência de Fibonacci de maneira mais eficiente. Para tal, vamos criar um vetor auxiliar <strong>int dp[MAXN]</strong>, onde <strong>MAXN</strong> é a maior posição da sequência que posso querer calcular. Ele começará com todos os valores iguais a -1 (pois sei que nenhum termo da sequência em posição positiva tem esse valor). Assim, se o valor de <strong>dp[i]</strong> for -1, então ainda não calculei esse valor. Agora basta refazer a função <strong>fib </strong>fazendo-a verificar, primeiramente, se já tenho salvo, em <strong>dp[x] </strong>("<strong>if(dp[x]!=-1)</strong>"), o valor de <strong>fib(x)</strong>, retornando-o se isso ocorrer. Caso eu ainda não tenha calculado esse valor, faço a função recursiva e lembro de salvar o valor calculado em <strong>dp[x]</strong> antes de retornar a função! Uma pequena observação é que existe uma função da <strong>cstring</strong> chamada <strong>memset </strong>que faz todos as posições de um array receberem algum valor escolhido. Ela tem três parâmetros e a seguinte gramática ("<strong>memset(nome_do_vetor, valor, sizeof(nome_do_vetor));</strong>"). Ela  troca todos os <strong>bytes </strong>do vetor pelo <strong>valor</strong> escolhido e, como um <strong>int</strong> tem 4 <strong>bytes</strong>, não podemos usá-la em todos os casos. Saiba que ela funciona para 0 e -1, o que felizmente é o nosso caso. Segue o código para melhor entendimento:</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/311962e08b79c6ed53d2.js"></script></p>
<p align="justify">Observe que, com essa função, evito vária chamadas recursivas, o que otimiza muito a complexidade, pois agora só calculo cada valor da sequência uma única vez, logo, a complexidade fica <strong>O(n)</strong>, onde <strong>n</strong> é a posição da sequência que queremos calcular. Para você entender isso melhor, veja como fica a nova árvore de recursão dessa versão mais eficiente da função Fib, que só calcula os valores 1 vez e para a recursão sempre que houver recálculo: <a href="http://noic.com.br/wp-content/uploads/2015/05/dp_fib.png"><img class="aligncenter size-full wp-image-4120" src="http://noic.com.br/wp-content/uploads/2015/05/dp_fib.png" alt="dp_fib" width="688" height="409" /></a> Em qualquer função recursiva, podemos [e devemos] guardar o valores já calculados e evitar recálculo com programação dinâmica. A função <strong>fib</strong> tem um único parâmetro, por isso podia guardar seu valores em um vetor. Se precisássemos usar uma função de nome <strong>dp</strong> que recebe dois inteiros como parâmetros, do tipo "<strong>int dp(int parametro1, int parametro2){}</strong>" iríamos guardar seus valores em uma matriz <strong>n</strong>x<strong>m </strong>("<strong>int tab[n][m];</strong>"), onde <strong>n</strong> é o maior valor possível de <strong>parametro1 </strong>e <strong>m</strong> o maior valor possível de <strong>parametro2</strong>. Desse modo, iríamos guardar o valor de <strong>dp(x, y)</strong> em <strong>tab[x][y]</strong>. Façamos agora algumas observações: As duas últimas linhas da função apresentada apresentada: "<strong>dp[x]=fib(x-1)+fib(x-2);</strong>" e "<strong>return dp[x];</strong>" podem ser substituídas por um único comando: "<strong>return dp[x]=<strong>fib(x-1)+fib(x-2);</strong></strong>", que executa exatamente os dois comando anteriores nessa mesma ordem. Usaremos sempre isso em programação dinâmica.</p>
<br />
<h3>Tipos de Abordagem</h3>
<p align="justify">Note que usamos uma função recursiva que chama os casos mais de cima (mais distantes dos casos base) da DP (como chamamos a função usa programação dinâmica), até chegar aos casos base e só então ir voltando a recursão. Esse tipo de abordagem, em que usamos uma função recursiva no método de dividir para conquistar para calcular os valores da DP é chamado de abordagem  <strong>Top-Down</strong>, pois começa dos casos de cima e vai descendo até chegar à raiz da DP. Existe outro método, em que fazemos o contrário: construimos os casos base e a partir dele vamos criando os casos mais de cima, até que cheguemos no caso procurado. Esse tipo de abordagem é conhecido como <strong>Bottom-Up</strong>.</p>
<br />
<p align="justify">No problema de Fibonacci, isso seria semelhante a criar um vetor de <strong>n</strong> posições de nome <strong>int </strong><strong>fib</strong>, por exemplo, inicializá-lo com os casos base já feitos ("<strong>fib[0]=0; fib[1]=1;</strong>") e então usarmos um <strong>for</strong> para percorrê-lo até <strong>n</strong>, fazendo com que cada posição <strong>i</strong> receba a soma dos valores guardador nas duas posições anteriores ("<strong>fib[i]=fib[i-1]+fib[i-2];</strong>"). Ao final do <strong>for</strong>,bastaria imprimir o valor salvo em <strong>fib[n]</strong>. Como vamos apenas percorrer o vetor uma vez, a complexidade continua <strong>O(n)</strong>. Segue o código para melhor entendimento:</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/5b572afa2b61a59e8723.js"></script></p>
<p align="justify">Os programas aqui fornecidos retornam os valores da sequência em <strong>O(n)</strong>, mas para usarmos isso, ou seja, chamarmos numeros de Fibonacci em posições por volta de 60, precisamos guardar valores maiores que um <strong>int</strong>. A variável <strong>int</strong> só guarda inteiros de 32-bit, ou seja, entre <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_b34e0f95baa48a3058826e247b7c96a5.gif' style='vertical-align: middle; border: none; ' class='tex' alt="-2^{31}" /></span><script type='math/tex'>-2^{31}</script> e <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_61abe8690cd8ebb41300652c4504ce4e.gif' style='vertical-align: middle; border: none; ' class='tex' alt="+2^{31}-1" /></span><script type='math/tex'>+2^{31}-1</script> (algo um pouco maior que 2 bilhões), mas a sequência de Fibonacci cresce muito rápido. Se quisermos chamar os números grandes de Fibonacci, teremos que guardar os valores (bem como declarar a função) do tipo <strong>long long int</strong>, que guarda inteiros de 64-bit (algo perto de <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_1d192bb209fa2f0f0cfdbe23eb00310b.gif' style='vertical-align: middle; border: none; ' class='tex' alt="10^{18}" /></span><script type='math/tex'>10^{18}</script>, positivos e negativos). A última observação é que a complexidade de uma DP, em qualquer caso, é o tamanho do array que vamos usar para guardar seus dados, ou estados, pois cada estado só deverá ser calculado uma única vez, no máximo. Ou seja, se usamos um vetor de tamanho <strong>n</strong>, a complexidade da DP é <strong>O(n)</strong>. Se usarmos uma matriz <strong>n</strong>x<strong>n</strong>, a complexidade fica <strong>O(n²)</strong>.</p>
<h3>O Problema da Mochila</h3>
<p align="justify">O Problema mais clássico de Progração Dinâmica talvez seja o KnapSack, ou o problema da mochila. Se você não o conhece, clique <a title="Intermediário Informática - Semana 4" href="http://noic.com.br/problemas-da-semana/informatica/intermediario-informatica-semana-4/" target="_blank">aqui</a> para ler uma maneira possível de enunciá-lo. De maneira geral, um ladrão irá roubar uma casa com uma mochila que suporta um peso <strong>s</strong>. Ele vê <strong>n</strong> objetos na casa e sabe estimar o peso <strong>p<sub>i </sub></strong>e o valor <strong>v<sub>i</sub> </strong>de cada objeto <strong>i</strong>. Com essas informações, qual o maior valor que o ladrão pode roubar sem rasgar sua mochila? Assim como nesse exemplo, Programação Dinâmica é muito comum em problemas que parecem ser resolvidos por algoritmos gulosos, mas não podem. No caso, o primeiro pensamento de alguém pode ser sempre pegar o objeto de maior valor que ainda não foi colocado na mochila, até que não caiba mais nenhum, mas essa ideia é facilmente quebrada com o seguinte exemplo, que segue o modelo de entrada explicado no link acima:</p>
<p align="justify">4 3</p>
<p align="justify">3 7</p>
<p align="justify">2 4</p>
<p align="justify">2 4</p>
<br />
<p align="justify">O programa guloso iria preferir o objeto mais valioso (1, de valor 7) e não caberá nenhum dos outros dois. Porém, é melhor que coloquemos na mochila os objetos 2 e 3, que somados têm peso 4 (cabe na mochila) e valor 8 (maior que 7). Depois de pensar um pouco mais, você pode pensar na "densidade de valor" do objeto. Faria um guloso que pusesse na mochila os objetos de maior "valor por grama". Porém, o mesmo caso de entrada mostrado acima mostra que esse guloso tomaria a mesma decisão errada que o outro. O que fazer então? Uma DP! Vale ressaltar que, na maioria das vezes (inclusive agora), faremos uma DP Top-Down por ser mais fácil e didática que a Bottom-Up.</p>
<br />
<p align="justify">Vamos criar dois vetores apenas para guardarmos o peso e o valor de cada objeto, assim, o peso do objeto <strong>i</strong> estará salvo em <strong>peso[i]</strong>, e o seu valor estará em <strong>valor[i]</strong>. Para responder o problema, tente pensar em um estado da DP como: estando os objetos em fila, qual o máximo que o ladrão pode roubar se ainda tiver disponível todos os objetos a partir de uma certa posição <strong>obj</strong> da fila, e a mochila ainda aguentar o peso <strong>aguenta</strong> sem rasgar, ou seja, tente implementar a função <strong>int knapsack(int obj, int aguenta){}</strong>. Ela deverá receber o número do objeto que está sendo verificado e quanto peso a mochila ainda aguenta, retornando, para tais parâmetros, o maior valor que que o ladrão pode roubar se ainda sobrar <strong>aguenta</strong> gramas na mochila e você puder colocar ou não colocar todos os objetos a partir de <strong>obj</strong>. A ideia é, dados os objetos em fila, em ordem qualquer de entrada, testá-los, um a um, se é melhor colocá-lo, ou não, testando todas as possibilidades com um DP. Para isso basta analisarmos o estado em que a DP ficaria se colocássemos e se não colocássemos o objeto que estamos olhando, e escolher o melhor deles.</p>
<br />
<p align="justify">Em uma DP, antes de qualquer coisa, veremos se o estado que estamos olhando já foi calculado, ou seja, se em algum momento já chamamos a função para os parâmetros atuais ("<strong>dp(obj, aguenta)</strong>"). Se isso ocorrer, deverá estar salvo na nossa tabela de DP, de nome <strong>tab</strong>, nos índices <strong>obj</strong> e <strong>aguenta</strong>. Vamos inicializá-la com todos os valores iguais a -1 com o <strong>memset</strong> e quando calcularmos algum valor, vamos substituí-lo na tabela, ou seja, se o valor salvo nela, para os parâmetros que estamos olhando, for maior ou igual a zero ("<strong>if(tab[obj][aguenta]&gt;=0)</strong>") retornamos o valor que está salvo lá ("<strong>return tab[obj][aguenta];</strong>").</p>
<br />
<p align="justify">As bases da DP são duas: se já olharmos todos os objetos da fila, ou seja, já estamos em uma posição maior que <strong>n</strong> ("<strong>if(obj&gt;n)</strong>"), ou se ela não aguentar mais peso algum ("<strong>if(aguenta==0)</strong>"), não podemos mais adicionar nada na mochila, ou seja, a função deve retornar valor 0.</p>
<p align="justify">Nos demais casos da DP, temos que olhar se o melhor é colocar ou não o objeto, então vejamos o que ocorrer nos dois casos! Vamos declarar o <strong>int nao_coloca</strong>, que receberá o maior valor que podemos obter sem colocar <strong>obj</strong> na mochila, e testando todos os outros da fila. Assim, o estado em que ficaremos seria: vamos olhar o próximo objeto (<strong>obj+1</strong>) e a mochila continuará ainda aguentando o mesmo que antes, pois não colocamos <strong>obj</strong> na mochila, logo, executamos o comando "<strong>nao_coloca=knapsack(obj+1, aguenta);</strong>". Agora, vamos testar se é possível colocar<b> </b><strong>obj</strong>, ou seja, se o peso de <strong>obj</strong> não é maior que o peso que a mochila aguenta ("<strong>if(peso[obj]&lt;=aguenta)</strong>"). Se for possível, devemos retornar que o máximo que podemos obter equivale ao valor do objeto que colocamos somado do melhor que podemos testando o próximo objeto, sendo que agora a mochila aguentará o que ela aguentava antes, subtraído do peso de <strong>obj</strong>. Em outras palavras, criaríamos a variável <strong>int coloca</strong> e atribuiríamos a ela o valor <strong>valor[obj]+knapsack(obj+1, aguenta-peso[obj)</strong>. Feito isso, retornamos o melhor, ou seja, o maior valor dentre o de colocar ou não colocar <strong>obj</strong> na mochila. Para isso, usaremos a função <strong>max</strong> da biblioteca de C++ <strong>algorithm</strong>, que recebe dois objetos quaisquer como parâmetros e retorna o maior deles, segundo os operadores "&lt;" e "&gt;". Retornaremos, portanto o maior dentre <strong>coloca </strong>e <strong>nao_coloca</strong>, lembrando de salvar antes o valor na tabela de DP ("<strong>return tab[obj][aguenta]=max(coloca, nao_coloca;</strong>").</p>
<br />
<p align="justify">Caso a função continue sua execução sem retornar, então não foi possível colocar o objeto e só temos uma opção: não colocá-lo, logo a função deve retornar o valor de <strong>nao_coloca</strong>, também salvando-o antes na tabela de DP. Assim, basta lemos todos os pesos e valores dos objetos na entrada e depois retornarmos o melhor possível dentre colocar ou não o primeiro objeto da fila, sendo que a mochila ainda aguenta seu valor inicial <strong>s</strong>, ou seja, devemos imprimir o valor de <strong>knapsack(1,</strong> s). Segue o código comentado para melhor entendimento:</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/4b4cfaf7351a85a2188e.js"></script></p>
<p align="justify">Você deve levar a ideia<strong> </strong>do problema da mochila, de testar todas as possibilidades de maneira eficiente, com você para o resto da vida. Muitos problemas de DP são resolvidos nesse estilo.</p>
<h3>Maior Subsequência Comum</h3>
<p align="justify">Este é outro problema muito clássico de Programação Dinâmica e que deve permanecer na sua cabeça enquanto você participar de competições de programação. Dadas duas sequências <strong>s<sub>1</sub></strong><sub> </sub>e <strong>s<sub>2</sub></strong>, uma de tamanho <strong>n</strong> e outra de tamanho <strong>m</strong>, qual a maior subsequência comum às duas que é mais longa? Lembre-se que uma subsequência de <strong>s<sub>1</sub></strong>,por exemplo,  não precisa ter seus membros adjacentes também adjacentes em <strong>s<sub>1</sub></strong>. Isto significa que {1, 3, 5} é uma subsequência de {1, 2, 3, 4, 5}, mesmo 1 não estando do lado do 3 na sequência original. A entrada terá três linhas Pense um pouco: que parâmetros você escolheria para serem os parâmetros da DP? Se teve uma boa ideia, experimente implementá-la, se não seguem a explicação e o código comentado.</p>
<br />
<p align="justify">Uma ótima ideia para representarmos os estados da DP são os finais das sequências. Ou seja, implemente uma função <strong>lcs</strong> (Longest Common Subsequence) que receba dois inteiros <strong>a</strong> e <strong>b</strong> e retorne a maior subsequência comum entre os <strong>a</strong> primeiros elementos de <strong>s1</strong> e os <strong>b</strong> primeiros elementos de <strong>s2</strong>. Assim, seja <strong>s1</strong>={1, 2, 3, 4, 5} e <strong>s2</strong>={1, 0, 3, -2, 5, 7}. A maior subsequência comum entre elas duas é {1, 3, 5}, pois estamos considerado todos os seu elementos, ou seja, como <strong>s1</strong> tem 5 elementos e <strong>s2</strong> tem 6, <strong>lcs(5, 6) </strong>retorna 3, que é o comprimento de {1, 3, 5}. Porém, se quiséssemos comparar a sequências só até o 3º termo da primeira e o 4º termo da segunda, ou seja, quiséssemos comparar as sequências {1, 2, 3} e {1, 0, 3, -2}, a maior subsequência comum a elas é {1, 3}, com dois elementos, logo <strong>lcs(3, 4)</strong> retorna 2.</p>
<br />
<p align="justify">Imagine que a entrada do problema consiste de três linhas: na primeira estão os inteiros <strong>n</strong> e<strong> m</strong> e, nas outras duas seguem <strong>n</strong> e<strong> </strong><strong>m</strong><strong> </strong>inteiros: os elementos de <strong>s1</strong> e <strong>s2</strong>, respectivamente. O programa deve gerar como  saída uma única linha com o valor da maior subsequência comum a <strong>s1</strong> e <strong>s2</strong>. Segue um exemplo de entrada e um de saída:</p>
<p align="justify">Entrada:</p>
<p align="justify">5 6</p>
<p align="justify">1 2 3 4 5</p>
<p align="justify">1 0 3 -2 5 7</p>
<p align="justify">Saída:</p>
<p align="justify">3</p>
<p align="justify">Vamos salvar os elementos de <strong>s1</strong> no vetor <strong>int</strong> <strong>s1[MAXN] </strong>e os de<strong> s2</strong> no vetor <strong>int s2[MAXN]</strong>, onde MAXN é o tamanho máximo das sequências. No caso, vamos definir o valor de MAXN como 1000.</p>
<br />
<p align="justify">Antes de tudo, lembre-se de salvar os resultados anteriores da função em uma tabela de DP, de nome <strong>tab</strong> por exemplo, onde termos o resultado de <strong>lcs(a,b)</strong> salvo em <strong>tab[a][b]</strong>. Ela começará com todos os valores iguais a -1, indicando nenhum deles foi calculado ainda. Assim, sempre no começo da função, cheque se aquele estado que você está calculando ainda não foi calculado. Se tiver sido, retorne o valor que você tem salvo para ele.</p>
<br />
<p align="justify">Desse modo, vamos pensar nos casos bases da DP. É possível calcular o valor da função instantaneamente se <strong>a</strong><strong>=0 </strong>ou se <strong>b=0</strong>, pois não é possível que haja subsequência de comprimento positivo em uma sequência de nenhum elemento, logo, nesses dois casos, a função deve retornar 0, e guardar o resultado na tabela de DP.</p>
<p align="justify">Vejamos agora o caso geral da função. Vamos calcular o valor de <strong>lcs(a, b)</strong>. Cheque se o <strong>a</strong>-ésimo elemento de <strong>s1</strong> é igual ao <strong>b</strong>-ésimo elemento de <strong>s2 </strong>("<strong>if(s1[a]==s2[b])</strong>"). Se eles forem iguais, então a maior subsequência será exatamente um elemento maior que a maior subsequência entre os <strong>a-1</strong> primeiros elementos de <strong>s1</strong> e o <strong>b-1</strong> primeiros elementos de <strong>s2</strong> (pois será exatamente ela somada ao novo elemento comum encontrado, que é <strong>s1[a]==s2[b]</strong>). Caso contrário, temos duas possibilidades:</p>
<ol>
<li>A maior subsequência comum termina exatamente no elemento  <strong>s1[a]</strong>. Nesse caso, sabemos que <strong>s2[b] </strong>não está nela, pois se estivesse, ela terminaria exatamente em <strong>s2[b]</strong>, visto que ele é o último elemento considerado de <strong>s2</strong>. Assim, não faz nenhuma diferença removermos esse elemento de <strong>s2</strong> e recalcularmos a comparação, pois a<strong> lcs</strong> continuará a mesma. Assim, podemos retornar o valor de <strong>lcs(a, b-1)</strong>, e salvá-lo na tabela de DP.</li>
<li>A maior subsequência comum não termina no elemento <strong>s1[a]</strong>. Nesse caso, sabemos que <strong>s1</strong><strong>[a]</strong> não nela, pelo mesmo motivo que <strong>s2[b] </strong>não estaria, no exemplo anterior. Desse modo, não faz nenhuma diferença removermos <strong>s1</strong><strong>[a] </strong>de <strong>s1</strong> e recalcularmos a comparação, pois a <strong>lcs</strong> continuará a mesma. Assim, podemos retornar o valor de <strong>lcs(a-1, b)</strong>, e salvá-lo na tabela de DP.</li>
</ol>
<p align="justify">Dentre as duas possibilidades, retornamos a maior delas! Agora basta implementarmos a função com essa recursão, lermos os tamanhos e elementos de <strong>s1</strong> e <strong>s2</strong> e imprimirmos o valor de <strong>lcs(n, m)</strong>, para considerarmos a maior subsequência comum a todos os elementos de <strong>s1</strong> e <strong>s2</strong>. Segue o código comentado para maior entendimento:</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/3fdd21fd4cd6b9f9b112.js"></script></p>
<p align="justify">Uma outra aplicação para a função <strong>lcs</strong> é a de encontrar a maior subsequência crescente, ou <strong>lis</strong> (Longest Increasing Subsequence) em <strong>O(n²)</strong>. Para isso, bastar reproduzirmos uma sequência em um segundo vetor, ordená-lo, e comparar a sequência original com a ordenada, chamando a função <strong>lis</strong>. A maior subsequência comum a uma sequência e sua versão ordenada é a maior subsequência ordenada da original. Segue o código para melhor entendimento:</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/4aac70479057bdb31b34.js"></script></p>
<p align="justify">Vale lembrar que uma sequência crescente é uma que não decresce, visto que um vetor ordenado tem a mesma definição (o <strong>sort</strong> não exclui elementos repetidos).</p>
