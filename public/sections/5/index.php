<p align="justify"> <strong>Autor: </strong> Rogério Júnior </p>
<p align="justify"> <strong>Fonte: </strong> <a href="noic.com.br">Noic</a> </p>

<h1>1.5 - Funções e Ordenação</h1>

<h2> Indice </h2>
<ol>
  <li> <a href="#funcoes"> Funções </a></li>
  <li> <a href="#ordenacao"> Ordenação </a></li>
</ol>

<a name="funcoes"></a>
<h2> Funções</h2>

<p align="justify">Nas aulas passadas, já usamos algumas funções, como <strong>scan </strong>e <strong>printf</strong>, <strong>strlen</strong> e <strong>strcmp</strong>. Perceba como funciona uma função genérica: ela é chamada pelo nome,e realiza uma séria de comandos, bem como retornar uma variável ou não, que dependem dos parâmetros que foram inseridos nela entre parênteses. Enfim, para chamarmos uma função genérica cujo nome seja <strong>funcao</strong>, escrevemos o comando "<strong>funcao(parametro1, parametro2, parametro 3, ...);</strong>". No <strong>scanf</strong>, por exemplo, os parâmetros são primeiro uma <strong>string</strong> (tudo que está entre aspas duplas), e depois uma série de ponteiros, ou seja, "endereços" para algumas variáveis. Na <strong>strcmp</strong>, os parâmetros são duas strings. O retorno de uma função é o valor que ela assume em função de seus parâmetros. A <strong>scanf</strong> retorna um inteiro: o número de objetos armazenados com sucesso, e, se ela para de funcionar antes de ler o que esperava, por fim de arquivo, ela retorna EOF (End Of File), que é -1. A <strong>strlen</strong> também retorna um inteiro, o tamanho de uma <strong>string</strong>. Veja portanto, que todas essas funções são do tipo <strong>int</strong>, pois retornam inteiros.</p>
<br />
<p align="justify">Assim como podemos declarar variáveis, também podemos declarar funções. Elas devem ser declaradas fora da <strong>main</strong>, pois não podemos declarar uma função dentro de outra. Vale lembrar, também, que elas devem ser declaradas <strong>antes</strong> da <strong>main</strong>, pois o computador executa comandos na ordem que lê e, assim como com as variáveis, não podemos chamar uma função sem antes declará-la.</p>
<br />
<p align="justify">A gramática da declaração de uma função começa pelo tipo da função (<strong>int</strong>,<strong> double</strong>,<strong> char</strong>, ...), depois abrimos parêntese e declaramos os parâmetros da função, dizendo seus tipos e nomes e os separando por vírgula. Fechados os parênteses, abrimos chaves e escrevemos os comandos que a função deve executar, que podem usar os parâmetros declarados. O que a função irá retornar é um comando que deve estar entre as chaves. Para fazermos a função retornar um valor <strong>x</strong> qualquer, que deve ser do mesmo tipo da função, escrevemos "<strong>return x;</strong>". Lembre-se que uma função fecha imediatamente após retornar um valor. Existe um tipo de função que não retorna nada, a <strong>void</strong>. A usamos somente para executar comandos, e não esperamos que ela assuma algum valor após executá-los. Ainda podemos usar o <strong>return</strong> nela, mas apenas como ordem para que encerre, sem retornar valor algum, através do comando "<strong>return;</strong>". Segue, para melhor fixação, um programa que, dados dois números, imprime o maior deles através da função <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_2ffe4e77325d9a7152f7086ea7aa5114.gif' style='vertical-align: middle; border: none; padding-bottom:2px;' class='tex' alt="max" /></span><script type='math/tex'>max</script>, que recebe dois inteiros e retorna o maior deles:</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/12a1c8f6ac0e0c61eaa5.js"></script></p>
<p align="justify">A lógica da função acima é muito simples: se (<strong>a&gt;b</strong>) retorne <strong>a </strong>como valor da função. Se a função não retornar, então <strong>a</strong> não era maior que <strong>b</strong>, logo <strong>b</strong><span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_de44c582df9d8d29dbbd70aca311c641.gif' style='vertical-align: middle; border: none; ' class='tex' alt="\leq" /></span><script type='math/tex'>\leq</script><strong>a</strong> e devemos retornar o valor de <strong>b</strong>.</p>
<br />
<p align="justify">Vale ressaltar que podemos fazer os parâmetros de uma função assumirem valores pré-definidos, quando não declarados na chamada. Se na declaração de <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_2ffe4e77325d9a7152f7086ea7aa5114.gif' style='vertical-align: middle; border: none; padding-bottom:2px;' class='tex' alt="max" /></span><script type='math/tex'>max</script> tivéssemos usados os parâmetros "<strong>(int a, int b=0)</strong>", então a função saberia que, quando não a informássemos o valor de <strong>b</strong>, este devia ser zero. Ou seja, fazendo isso, ao chamarmos a função "<strong>max(x);</strong>" ela retornaria <strong>x</strong> se ele fosse positivo e 0 se ele não fosse, pois faria exatamente o mesmo de chamarmos "<strong>max(x, 0);</strong>". Para fazer isso, lembre-se que a função recebe os parâmetros na ordem em que foram declarados, portanto, não posso atribuir um valor "reserva" a um parâmetro se ainda houver parâmetros sem valores pré-definidos após ele ou salvar valores para dois parâmetros e deixar alguns sem valores salvos entre eles.</p>
<br />
<p align="justify">Para fixar ainda mais a ideia, tente escrever uma função que recebe um inteiro e retorna seu módulo (valor absoluto). Se não conseguir, segue o código, mas realmente tente fazê-la antes de lê-lo.</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/2032c5619e46555643ee.js"></script></p>
<p align="justify">&nbsp;</p>
<p align="justify"><strong>Recursividade</strong></p>
<p align="justify">É importante saber que, dentro de uma função, podemos fazer qualquer coisa, exceto declarar outra função, como declarar e chamar variáveis, usar <strong>if </strong>e <strong>for</strong> e, até, chamar outras funções que já tenhamos declarado, inclusive ela mesma! Quando isso ocorre (uma função chama a si mesma), dizemos que é uma função recursiva. Recursão resolve uma infinidade de problema e é imprescindível que você saiba usá-la para fazer qualquer competição de informática. Grafos e Programação Dinâmica, que virão em aulas futuras, usam recursão na maioria de seus algoritmos.</p>
<br />
<p align="justify">Para entendermos melhor a ideia, vamos fazer o problema mais clássico de recurção, a função "<strong>int fib(int n)</strong>", que retornará o n-ésimo termo da <a href="http://pt.wikipedia.org/wiki/Sequ%C3%AAncia_de_Fibonacci" onclick="_gaq.push(['_trackEvent', 'outbound-article', 'http://pt.wikipedia.org/wiki/Sequ%C3%AAncia_de_Fibonacci', 'Sequência de Fibonacci']);" title="Fibonacci - Wikipedia"  target="_blank">Sequência de Fibonacci</a>, onde n é não negativo. A primeira coisa que pensamos ao falar em recursividade é o que fazer para que a função não se chame infinitamente. Primeiro, temos que estabelecer um caso base, um certo tipo de entrada em que a função não usa a recursão, mas calcula o seu valor de retorno sem se chamar. No caso de Fibonacci, esse valores serão 0 e 1, pois sabemos que os dois primeiros termos da sequência (termo 0 e termo 1) são exatamente 0 e 1, respectivamente. Assim, a primeira linha da nossa função, antes de chamar a recursão, deve verificar se <strong>n</strong> <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_de44c582df9d8d29dbbd70aca311c641.gif' style='vertical-align: middle; border: none; ' class='tex' alt="\leq" /></span><script type='math/tex'>\leq</script> 1, pois se for, deve retornar <strong>n</strong>. Feito isso, podemos chamar a recursão. Na sequência de Fibonacci, a partir do índice 2, um termo é a soma dos dois anteriores, ou seja, <strong>fib(n)=fib(n-1)+fib(n-2)</strong>. Para implementar isso na função fazemos com que ela retorne essa soma, através do comando "<strong>return <strong>fib(n-1)+fib(n-2);</strong></strong>". Segue o código de um programa que usa essa função para calcular o n-ésimo número de Fibonacci:</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/97483f4174568e113b06.js"></script></p>
<p align="justify">Outro ponto a ser notado quando usamos recursividade é garantir que em algum momento a recursão chegará nos casos base. No caso, note que <strong>n</strong> é sempre inteiro e a função sempre chama a recursão para valores menores que<strong> n</strong>, ou seja, ele vai sempre diminuindo e uma hora chegará em 1 ou em 0. São esses os dois pontos importantes: faça um caso base que retorne valor sem chamada recursiva e garanta que todos os outros casos irão caminhar para ele. Note que tivemos que fazer dois casos base (0 e 1) justamente porque a função chama a recursividade para dois valores (<strong>n-1</strong> e <strong>n-2</strong>). Segue um ilustração para entendermos melhor o que acontece quando usamos recursão, usando o exemplo <strong>fib(5)</strong>.</p>
<br />
<p style="text-align: left;"><a href="http://noic.com.br/wp-content/uploads/2015/04/fib.png"><img class="aligncenter wp-image-3491 size-full" src="http://noic.com.br/wp-content/uploads/2015/04/fib.png" alt="fib" width="688" height="409" /></a>Observe, na ilustração, como as funções de cima vão chamando as de baixo e como elas sempre vão parar nos casos base, onde acaba a recursão pois a função retorna sem precisar chamar a recursividade, no caso em <strong>fib(1) </strong>e <strong>fib(0)</strong>. O programa realiza estas chamadas sempre pela mais à esquerda primeiro, pois no código, repare que chamamos <strong>fib(n-1)</strong> antes de <strong>fib(n-2)</strong>. Somando o resultado dos filhos na árvore de recursão, obtemos o resultado de determinada chamada da função.</p>
<p style="text-align: left;">Um outro exemplo de recursão é o Algoritmo de Euclides para determinação do MDC entre dois números. Se você não o conhece, clique <a href="http://pt.wikipedia.org/wiki/Algoritmo_de_Euclides" onclick="_gaq.push(['_trackEvent', 'outbound-article', 'http://pt.wikipedia.org/wiki/Algoritmo_de_Euclides', 'aqui']);" title="Algoritmo de Euclides"  target="_blank">aqui</a>.</p>
<br />
<p style="text-align: left;">Resumindo, para encontrar o MDC(a, b), supondo sem perda de generalidade que a <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_2d9362c6490cded6ecd93e0bf42a25bb.gif' style='vertical-align: middle; border: none; ' class='tex' alt="\geq" /></span><script type='math/tex'>\geq</script> b, verifico:</p>
<br />
<p style="text-align: left;">1. Se a é múltiplo de b, MDC(a,b)=b;</p>
<p style="text-align: left;">2. Se não, MDC(a,b)=MDC(b, r), onde r é o resto que a deixa na divisão por b.</p>
<br />
<p style="text-align: left;">Você já conseguiu perceber como implementar a função recursiva? Já identificou o caso base e a recursividade? Enfim, tente fazer essa questão sozinho. Se não conseguir, seguem a explicação e o código abaixo.</p>
<br />
<p style="text-align: left;">Vamos criar a função recursiva "<strong>int mdc(int x, int y)</strong>", que receberá dois inteiros <strong>x</strong> e <strong>y</strong> como parâmetros e retornará o mdc entre eles. Vamos primeiro garantir que <strong>x</strong> é maior que <strong>y</strong>, trocando seus valores se ele não for. O caso base, em que a função retorna valor sem recursão ocorre quando <strong>x</strong> é múltiplo de <strong>y</strong>, ou seja, deixa resto zero na divisão por <strong>y</strong>, quando sabemos que <strong>y</strong> será o mdc entre eles. Em C++, lembre que o operador "%" é quem diz resto na divisão, ou seja, escreveremos, na função, o comando: "<strong>if(x%y==0) return y;</strong>"</p>
<br />
<p style="text-align: left;">Quando isso não ocorre, chamamos a recursão conforme diz o algoritmo, com o comando "<strong>return mdc(y, x%y);</strong>". Note que o resto da divisão de <strong>x </strong>por <strong>y</strong> é sempre menor que <strong>y</strong>, logo o segundo parâmetro vai sempre diminuindo, assim como o primeiro, pois ele será o menor entre os dois parâmetros da função que chamou a recursão (<strong>y</strong><span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_de44c582df9d8d29dbbd70aca311c641.gif' style='vertical-align: middle; border: none; ' class='tex' alt="\leq" /></span><script type='math/tex'>\leq</script><strong>x</strong>). Como o <strong>y</strong> vai sempre diminuindo e é inteiro positivo, ele terá que chegar em um divisor de <strong>x</strong>, pois no pior dos casos chegará até <strong>1</strong>, que divide qualquer inteiro positivo. Desse modo, a função sempre chegará nos casos base. Segue o código:</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/d76ec49d486444fddb69.js"></script></p>
<p style="text-align: left;">Veja, novamente a ilustração da recursão quando chamamos, no exemplo, mdc(756, 484):</p>
<p style="text-align: left;"><a href="http://noic.com.br/wp-content/uploads/2015/04/mdc.png"><img class="aligncenter wp-image-3495 size-full" src="http://noic.com.br/wp-content/uploads/2015/04/mdc.png" alt="mdc" width="180" height="403" /></a></p>
<p style="text-align: left;">Observe que, novamente, a função chama a recursão até chegar ao caso base mdc(28, 4), onde ela retorna 4 sem precisar de recursividade pois 4 é divisor de 28.</p>

<a name="ordenacao"></a>
<h2> Ordenação</h2>

<p align="justify">Imagine o seguinte problema, de enunciado muito simples: Dado um vetor de <strong>n</strong> inteiros, todos menores que <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_4899fb44f14867ddc63aa25d835c547f.gif' style='vertical-align: middle; border: none; ' class='tex' alt="10^6" /></span><script type='math/tex'>10^6</script>, imprima todos os seus elementos em ordem crescente. A entrada consistirá de duas linhas: a primeira terá um único inteiro: o valor de <strong>n</strong>, e a segunda terá os <strong>n</strong> elementos do vetor. Uma primeira ideia, que resolveria o problema seria fazer uma lista dos índices dos números que já imprimimos, depois, percorremos o vetor procurando o menor número que ainda não foi impresso e o imprimimos, repetindo o processo <strong>n </strong>vezes, até imprimirmos todos os números. Tal ideia é uma adaptação de um algoritmo de ordenação conhecido como <a href="http://pt.wikipedia.org/wiki/Selection_sort" onclick="_gaq.push(['_trackEvent', 'outbound-article', 'http://pt.wikipedia.org/wiki/Selection_sort', 'Selection Sort']);" title="Selection Sort - Wikipedia"  target="_blank">Selection Sort</a>. Implementar essa ideia usa apenas comandos que já conhecemos. Para fazermos uma lista eficiente, basta criarmos um vetor de inteiros de nome <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_ecd2ec43c588ae012e3550fcc55d6009.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="lista" /></span><script type='math/tex'>lista</script>. No começo, todos os valores nele salvo serão 0. Toda vez que imprimimos um número salvo na posição <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_865c0c0b4ab0e063e5caa3387c1a8741.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="i" /></span><script type='math/tex'>i</script> do vetor, fazemos com que <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_58fea2d4975068d072979fb12b4f7255.gif' style='vertical-align: middle; border: none; ' class='tex' alt="lista[i]" /></span><script type='math/tex'>lista[i]</script> receba 1. Para isso, é bom saber que toda variável global (declarada fora da main), se não receber um valor logo na declaração, é inicializada com o valor 0, assim como um vetor global será inicializado com todos os seus valores iguais a 0. Assim, verificar se um número <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_865c0c0b4ab0e063e5caa3387c1a8741.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="i" /></span><script type='math/tex'>i</script> está na lista é verificar se "<strong>(lista[i]==1)</strong>". Para identificar o menor número do vetor usaremos as variáveis <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_63299e155369cbf939ab9bb590522683.gif' style='vertical-align: middle; border: none; padding-bottom:2px;' class='tex' alt="menor" /></span><script type='math/tex'>menor</script> e <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_fcb6f3e6168e7f906b568d9627c1ba52.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="ind" /></span><script type='math/tex'>ind</script>_<span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_63299e155369cbf939ab9bb590522683.gif' style='vertical-align: middle; border: none; padding-bottom:2px;' class='tex' alt="menor" /></span><script type='math/tex'>menor</script>. A primeira começará com um valor muito grande (maior que o valor máximo de um elemento do vetor) e percorreremos todo o vetor, verificando, para cada um de seus elementos, se ele é menor que o número salvo em <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_63299e155369cbf939ab9bb590522683.gif' style='vertical-align: middle; border: none; padding-bottom:2px;' class='tex' alt="menor" /></span><script type='math/tex'>menor</script> e se seu índice não está na lista dos já impressos. Se for, faremos <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_63299e155369cbf939ab9bb590522683.gif' style='vertical-align: middle; border: none; padding-bottom:2px;' class='tex' alt="menor" /></span><script type='math/tex'>menor</script> receber seu valor e <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_fcb6f3e6168e7f906b568d9627c1ba52.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="ind" /></span><script type='math/tex'>ind</script>_<span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_63299e155369cbf939ab9bb590522683.gif' style='vertical-align: middle; border: none; padding-bottom:2px;' class='tex' alt="menor" /></span><script type='math/tex'>menor</script> receber seu índice, e após percorrermos todos o vetor, imprimiremos o valor salvo em <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_63299e155369cbf939ab9bb590522683.gif' style='vertical-align: middle; border: none; padding-bottom:2px;' class='tex' alt="menor" /></span><script type='math/tex'>menor</script> e adicionaremos <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_fcb6f3e6168e7f906b568d9627c1ba52.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="ind" /></span><script type='math/tex'>ind</script>_<span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_63299e155369cbf939ab9bb590522683.gif' style='vertical-align: middle; border: none; padding-bottom:2px;' class='tex' alt="menor" /></span><script type='math/tex'>menor</script> à lista dos já impressos. Segue a implementação da ideia, para <strong>n</strong> <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_de44c582df9d8d29dbbd70aca311c641.gif' style='vertical-align: middle; border: none; ' class='tex' alt="\leq" /></span><script type='math/tex'>\leq</script> 1000. Ela usará o comando <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_f1edc500eb1136f10c17eeffb9eecbc5.gif' style='vertical-align: middle; border: none; ' class='tex' alt="define" /></span><script type='math/tex'>define</script>. Ele tem a gramática: "#<strong>define a b</strong>", e não precisa de "<strong>;</strong>". Tal comando iria simplesmente procurar no código, a partir da linha em que foi escrito, todas as vezes que escrevi "<strong>a</strong>" e trocaria por "<strong>b</strong>". No código usarei, por exemplo, "<strong>#define MAXN 1010</strong>" e o programa substituirá todos os "<strong>MAXN</strong>"que aparecerem pelo número 1010, antes de compilar o programa. É uma questão de estética e facilidade de escrita.</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/d1b114d65c0b2351b01a.js"></script></p>
<p align="justify">Outra ideia que também geralmente ocorre quando estamos começando a programar e nos deparamos com esse problema é a de ir trocando os números do vetor de lugar à medida em que encontramos um número no vetor que é maior que o que lhe sucede. Tal ideia é um algoritmo conhecido como <a href="http://pt.wikipedia.org/wiki/Bubble_sort" onclick="_gaq.push(['_trackEvent', 'outbound-article', 'http://pt.wikipedia.org/wiki/Bubble_sort', 'Bubble Sort']);" title="Bubble Sort - Wikipedia"  target="_blank">Bubble Sort</a>. Ou seja, salvaríamos os números da entrada em um vetor de inteiros de nome <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_c4d9b3f5cbfe7a6a107edbe6648a2d91.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="vetor" /></span><script type='math/tex'>vetor</script>, percorreríamos ele por completo e, toda vez que encontrássemos um índice <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_865c0c0b4ab0e063e5caa3387c1a8741.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="i" /></span><script type='math/tex'>i</script> tal que <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_f2684c24cadb4019aa6a0dbdf0330435.gif' style='vertical-align: middle; border: none; ' class='tex' alt="vetor[i]<vetor[i+1]" /></span><script type='math/tex'>vetor[i]<vetor[i+1]</script>, trocaríamos os valores de <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_3e20e0bbafb5847b2b3be736bad2f1b6.gif' style='vertical-align: middle; border: none; ' class='tex' alt="vetor[i]" /></span><script type='math/tex'>vetor[i]</script> e <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_6cf5aa2997d62c42346953dd40577770.gif' style='vertical-align: middle; border: none; ' class='tex' alt="vetor[i+1]" /></span><script type='math/tex'>vetor[i+1]</script>, repetindo esse processo até que todo o vetor estivesse ordenado. Feito isso, imprimiríamos seus valores um a um. Para descobrir quando o vetor está ordenado, declaramos um inteiro <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_57833b41f637091fa45830e502701c05.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="ordenado" /></span><script type='math/tex'>ordenado</script>, que começará com o valor 0. Toda vez que recomeçamos o processo de procurar "elementos invertidos" no vetor, supomos que ele está ordenado e fazemos <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_57833b41f637091fa45830e502701c05.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="ordenado" /></span><script type='math/tex'>ordenado</script> receber 1. Se encontramos alguma inversão, além de trocar os elementos, fazemos <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_57833b41f637091fa45830e502701c05.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="ordenado" /></span><script type='math/tex'>ordenado</script> receber 0, indicando que ainda há desordenações no vetor. Logo, devemos repetir o processo enquanto <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_57833b41f637091fa45830e502701c05.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="ordenado" /></span><script type='math/tex'>ordenado</script> for 0, pois quando tudo estiver em ordem, ele receberá 1 no começo do loop e, como não haverá inversões, manterá este valor até o final. Segue o código:</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/c5a147ad3f9bd29a6f6f.js"></script></p>
<p align="justify">Os dois algoritmos acima são bons, se o número de elementos a serem ordenados for pequeno. Até agora, vimos apenas como resolver problemas, mas não nos preocupamos com a eficiência dos algoritmos usados, ou seja, quão rápido eles resolvem o problema. A <a href="http://pt.wikipedia.org/wiki/Complexidade_computacional" onclick="_gaq.push(['_trackEvent', 'outbound-article', 'http://pt.wikipedia.org/wiki/Complexidade_computacional', 'complexidade de um algoritmo']);" title="Complexidade Computacional - Wikipedia"  target="_blank">complexidade de um algoritmo</a> é quantas operações ele vai fazer, ou, do que depende, proporcionalmente, essa quantidade de operações. Se o programa tiver uma complexidade muito grande, ele levará Time Limit Exceeded, que significa que o seu programa levou tempo demais para resolver o problema e por isso não foi aceito. Veja, que no primeiro código, do Selection Sort, vamos percorrer o vetor várias vezes. Se o vetor tem <strong>n</strong> posições, então percorrê-lo todo usa mais ou menos <strong>n</strong> operações, pois devemos olhar cada casa do vetor. Mais ou menos <strong>n</strong> significa que este número de operações dependerá unicamente de <strong>n</strong>, e não mais de nenhuma outra variável, e crescerá proporcionalmente a <strong>n</strong>. Além disso, o programa não o percorre só uma vez: para cada número que vou imprimir, o programa percorre o vetor inteiro procurando o menor. Assim, vou percorrer o vetor <strong>n</strong> vezes, ou seja, farei <strong>n</strong> operações <strong>n</strong> vezes, logo o programa fará mais ou menos  <strong>n² operações</strong>. Isso significa que a complexidade do problema é quadrática, ou seja, o número de cálculos que ele fará é proporcional ao quadrado de uma variável. Para representar isso, usamos a notação "<strong>O(complexidade)</strong>", significando que o número de operações é proporcional à <strong>complexidade</strong>. No, caso, a complexidade do programa é <strong>O(n²)</strong>.</p>
<br />
<p align="justify">Vamos agora analisar o segundo código, do Bubble Sort. Repare que, novamente, vou percorrer o todo o vetor e isso tem complexidade <strong>O(n)</strong>. Porém vou repetir essa operação várias vezes, até que cada elemento esteja na sua posição certa de ordenação. Como os elementos "andam" uma posição por repetição e a distância máxima entre eles e a suas posições finais é no máximo <strong>n</strong> posições, o tamanho do vetor, posso ter que repetir o comando de percorrer o vetor cerca <strong>n</strong> vezes. Novamente, executo um comando de complexidade <strong>O(n) </strong>(percorrer todo o vetor) <strong>n </strong>vezes, o que gera uma complexidade de <b>O(n²)</b>.</p>
<br />
<p align="justify">Para a OBI, devemos considerar, por boa prática, que o computador faz cerca de 1 milhão de operações por segundo e que o tempo limite de execução é  1 segundo. Em outras palavras, nosso código deve ter complexidade de, no máximo, O(<span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_4899fb44f14867ddc63aa25d835c547f.gif' style='vertical-align: middle; border: none; ' class='tex' alt="10^6" /></span><script type='math/tex'>10^6</script>) . Se o valor de <strong>n</strong>, for menor que 1000, então nossos algoritmos que rodam em O(<strong>n²</strong>) irão se encaixar n0 limite. Mas, e se o valor de <strong>n</strong> for até <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_396a8c0267f4feffdaadf71c2911d8bc.gif' style='vertical-align: middle; border: none; ' class='tex' alt="10^5" /></span><script type='math/tex'>10^5</script>? Precisaremos de um algoritmo mais eficiente.</p>
<br />
<p align="justify">Existe uma ideia muito importante e imprescindível para qualquer um que queira participar de uma competição de informática: a de dividir para conquistar. A ideia é que para resolver um problema, pode ser mais fácil dividí-lo em casos menores, mais fáceis e resolvê-los um a um, e depois juntá-los para resolver o caso maior, na maioria das vezes com recursão. No caso de ordenação, pense: se eu tiver dois vetores ordenados e decidir juntá-los para fazer um vetor maior, também ordenado, não é bem mais simples? Essa é a ideia de um algoritmo conhecido chamado <a href="http://pt.wikipedia.org/wiki/Merge_sort" onclick="_gaq.push(['_trackEvent', 'outbound-article', 'http://pt.wikipedia.org/wiki/Merge_sort', 'Merge Sort']);" title="Merge Sort - Wikipedia"  target="_blank">Merge Sort</a>. Veja: se tenho o <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_e308fad9d0ec2a8575b23c199c7918df.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="vetor1" /></span><script type='math/tex'>vetor1</script> ordenado e o <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_2fd2375ed9c8ed5a74aff7a2ff0349bd.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="vetor2" /></span><script type='math/tex'>vetor2</script>, também ordenado, e quero juntá-los para formar o <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_2ffdd6a28e7d473e1cc2f9e5d830f2f0.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="vetorzao" /></span><script type='math/tex'>vetorzao</script>, também ordenado, basta que eu percorra os dois vetores, sempre olhando para o começo deles e inserindo em <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_2ffdd6a28e7d473e1cc2f9e5d830f2f0.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="vetorzao" /></span><script type='math/tex'>vetorzao</script> o menor dentre o primeiro elemento ainda não inserido de <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_e308fad9d0ec2a8575b23c199c7918df.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="vetor1" /></span><script type='math/tex'>vetor1</script> e de <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_2fd2375ed9c8ed5a74aff7a2ff0349bd.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="vetor2" /></span><script type='math/tex'>vetor2</script>. Segue uma figura que explica como juntar os vetores ordenados {1, 3, 5} e {2, 3, 4} para criarmos um vetor com os 6 elementos ordenados:</p>
<p align="justify"><a href="http://noic.com.br/wp-content/uploads/2015/04/merge-sort.png"><img class="aligncenter wp-image-3531 size-full" src="http://noic.com.br/wp-content/uploads/2015/04/merge-sort.png" alt="merge sort" width="309" height="1083" /></a></p>
<p align="justify">&nbsp;</p>
<p align="justify">&nbsp;</p>
<p align="justify">Vamos implementar a ideia! Basta usar um <strong>for</strong> para percorrer o primeiro vetor e, dentro dele, um <strong>while</strong>, que irá até o último elemento de <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_2fd2375ed9c8ed5a74aff7a2ff0349bd.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="vetor2" /></span><script type='math/tex'>vetor2</script> que é menor que o elemento de <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_e308fad9d0ec2a8575b23c199c7918df.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="vetor1" /></span><script type='math/tex'>vetor1</script> que estou olhando, para que, em cada posição do <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_e308fad9d0ec2a8575b23c199c7918df.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="vetor1" /></span><script type='math/tex'>vetor1</script> eu antes adicione todos os elementos de <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_2fd2375ed9c8ed5a74aff7a2ff0349bd.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="vetor2" /></span><script type='math/tex'>vetor2</script> que são menores que ele, para só então adicioná-lo a <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_2ffdd6a28e7d473e1cc2f9e5d830f2f0.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="vetorzao" /></span><script type='math/tex'>vetorzao</script>. Feito isso, basta adicionarmos todos os elementos que faltam de <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_2fd2375ed9c8ed5a74aff7a2ff0349bd.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="vetor2" /></span><script type='math/tex'>vetor2</script>. Segue a implementação de um programa que dado o tamanho de um vetor seguido de seus elementos ordenados e o tamanho de outro vetor, também seguido de seus elementos ordenados, imprime o <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_2ffdd6a28e7d473e1cc2f9e5d830f2f0.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="vetorzao" /></span><script type='math/tex'>vetorzao</script>, que é a junção ordenada dos dois vetores.</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/16cfcca7d34b63c1f4cb.js"></script></p>
<p align="justify">Note que a função apenas percorre dois vetores que juntos têm tamanho <strong>n</strong>, logo a complexidade dela é <strong>O(n)</strong>.</p>
<br />
<p align="justify">Agora vamos usar a ideia de dividir para conquistar. Se sempre formos separando o vetor ao meio, ordenando as duas metades e depois juntarmos as duas com uma função semelhante à <strong>merge</strong>, ficará mais fácil pois eventualmente chegaremos a vetores de uma única posição, que já estarão ordenados! Assim, basta fazermos a função recursiva <strong>void merge_sort(int ini, int fim){}</strong> recursiva que recebe o começo e o fim do intervalo que irá ordenar (inclusive). No seu começo, ela checa se o começo é igual ao fim (intervalo de um único elemento), se for, ela simplesmente retorna, pois o intervalo já estará ordenado. Se não, ela divide o vetor mais ou menos no meio e chama a si mesma para esses novos dois intervalos com o comando "<strong>merge_sort(ini, (ini+fim)/2); merge_sort((ini+fim)/2+1, fim);</strong>". Feito isso, o vetor em questão estará dividido ao meio em dois vetores ordenados, e realizaremos os comandos da <strong>merge </strong>para criarmos um novo vetor <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_53e5733361417423cbec0979f23b3def.gif' style='vertical-align: middle; border: none; padding-bottom:2px;' class='tex' alt="aux" /></span><script type='math/tex'>aux</script> que será a junção dos dois intervalos. Feito isso, faremos o intervalo antigo receber o vetor <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_53e5733361417423cbec0979f23b3def.gif' style='vertical-align: middle; border: none; padding-bottom:2px;' class='tex' alt="aux" /></span><script type='math/tex'>aux</script>. Note que o caso base da recursão são os intervalos de um único elemento, onde a função retorna sem chamar a recursão, e que a árvore recursiva caminha para este caso base, pois sempre vamos dividindo o intervalo ao meio e, criando intervalos cada vez menores, eles eventualmente terão tamanho 1. Segue o código de um problema que recebe um vetor e imprime seus elementos ordenadamente através da função <strong>merge_sort</strong>.</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/68476d973793bf9d5cf9.js"></script></p>
<p align="justify">Para fixar ainda mais a ideia, segue uma <a href="http://pt.wikipedia.org/wiki/Merge_sort#/media/File:Merge-sort-example-300px.gif" onclick="_gaq.push(['_trackEvent', 'outbound-article', 'http://pt.wikipedia.org/wiki/Merge_sort#/media/File:Merge-sort-example-300px.gif', 'animação da Wikipédia']);" title="MergeSort.gif"  target="_blank">animação da Wikipédia</a> que simula o Merge Sort no vetor {6, 5, 3, 1 , 8, 7 , 3, 4}:</p>
<p align="justify"><a href="http://noic.com.br/wp-content/uploads/2015/04/Merge-sort-example-300px.gif"><img class="aligncenter wp-image-3533 size-full" src="http://noic.com.br/wp-content/uploads/2015/04/Merge-sort-example-300px.gif" alt="Merge-sort-example-300px" width="300" height="180" /></a></p>
<p align="justify">&nbsp;</p>
<p align="justify">Vamos analisar, agora, a complexidade da função <strong>merge_sort</strong>. Observe a seguinte ilustração da chamada do Merge Sort no vetor usado de exemplo acima:</p>
<p align="justify"><a href="http://noic.com.br/wp-content/uploads/2015/04/merge-sort-tree.png"><img class="aligncenter wp-image-3534 size-full" src="http://noic.com.br/wp-content/uploads/2015/04/merge-sort-tree.png" alt="merge sort tree" width="407" height="237" /></a></p>
<p align="justify">&nbsp;</p>
<p align="justify">Observe que na linha <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_865c0c0b4ab0e063e5caa3387c1a8741.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="i" /></span><script type='math/tex'>i</script> da árvore de recursão (começando da linha 0) temos que unir <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_91c474acddeedae9e86913ee8bb17ce0.gif' style='vertical-align: middle; border: none; ' class='tex' alt="2^i" /></span><script type='math/tex'>2^i</script> vetores ordenados de tamanho <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_7970a585753867ba58edaa30ee8a126e.gif' style='vertical-align: middle; border: none; ' class='tex' alt="\frac{n}{2^i}" /></span><script type='math/tex'>\frac{n}{2^i}</script>. Como já vimos que juntar dois vetores ordenados tem complexidade <strong>O(n) </strong>(onde <strong>n</strong> é o tamanho do vetor final), estaremos repetindo, em cada linha, <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_91c474acddeedae9e86913ee8bb17ce0.gif' style='vertical-align: middle; border: none; ' class='tex' alt="2^i" /></span><script type='math/tex'>2^i</script> vezes uma operação de complexidade <strong>O(<span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_7970a585753867ba58edaa30ee8a126e.gif' style='vertical-align: middle; border: none; ' class='tex' alt="\frac{n}{2^i}" /></span><script type='math/tex'>\frac{n}{2^i}</script>)</strong>, o que gera, em cada linha uma complexidade igual a <strong>O(<span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_794b1e58a2c03e6e81f94fb7641f3789.gif' style='vertical-align: middle; border: none; ' class='tex' alt="2^i\cdot\frac{n}{2^i}" /></span><script type='math/tex'>2^i\cdot\frac{n}{2^i}</script>) = <strong>O(n)</strong></strong>. Mas quantas linhas a função chamará? Repare que dividiremos o vetor ao meio até que só reste 1 elemento em cada intervalo, logo, sendo <strong>m</strong> a quantidade de linhas, <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_2965940c27d60f6b0451b14e95aafe94.gif' style='vertical-align: middle; border: none; ' class='tex' alt="\frac{n}{2^m}=1\Leftrightarrow n=2^m\Leftrightarrow\log_2n=\log_2 2^m=m\Leftrightarrow m=\log_2n" /></span><script type='math/tex'>\frac{n}{2^m}=1\Leftrightarrow n=2^m\Leftrightarrow\log_2n=\log_2 2^m=m\Leftrightarrow m=\log_2n</script>. Logo, como são <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_1a5f617dcc550e6d54f157aed0dc1f39.gif' style='vertical-align: middle; border: none; ' class='tex' alt="\log_2n" /></span><script type='math/tex'>\log_2n</script> linhas, repetiremos <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_1a5f617dcc550e6d54f157aed0dc1f39.gif' style='vertical-align: middle; border: none; ' class='tex' alt="\log_2n" /></span><script type='math/tex'>\log_2n</script> vezes uma operação de complexidade <strong>O(n)</strong>, o que gera uma complexidade de <strong><span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_f49341ab621f12e8cb93d0146ea51d34.gif' style='vertical-align: middle; border: none; ' class='tex' alt="O(n\log n)" /></span><script type='math/tex'>O(n\log n)</script></strong> (em informática, ao usarmos o termo <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_cb139ffd45872a9a5f17ece5cdb1d314.gif' style='vertical-align: middle; border: none; ' class='tex' alt="\log" /></span><script type='math/tex'>\log</script>, nos referimos a logaritmo na base 2, não na base 10). Agora, se <strong>n</strong> for <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_396a8c0267f4feffdaadf71c2911d8bc.gif' style='vertical-align: middle; border: none; ' class='tex' alt="10^5" /></span><script type='math/tex'>10^5</script>, a complexidade do programa será <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_2dc457dc5a7cffd0d9749cdbd2325eeb.gif' style='vertical-align: middle; border: none; ' class='tex' alt="O(10^5\log10^5)=O(10^5\cdot17)\approx O(10^6)" /></span><script type='math/tex'>O(10^5\log10^5)=O(10^5\cdot17)\approx O(10^6)</script>, o que passa no tempo do corretor da OBI.</p>
<p align="justify">&nbsp;</p>
<p align="justify"><strong>Um pouco de C++</strong></p>
<p align="justify">Até agora, no curso, usamos apenas funções da linguagem C. Agora vamos ver um pouco do que o C++ tem a nos oferecer em ordenação. Na biblioteca <em><a href="http://www.cplusplus.com/reference/algorithm/" onclick="_gaq.push(['_trackEvent', 'outbound-article', 'http://www.cplusplus.com/reference/algorithm/', 'algorithm']);" title="Algorithm - cplusplus"  target="_blank">algorithm</a></em> temos uma função chamada <em><a href="http://www.cplusplus.com/reference/algorithm/sort/" onclick="_gaq.push(['_trackEvent', 'outbound-article', 'http://www.cplusplus.com/reference/algorithm/sort/', 'sort']);" title="sort - cplusplus"  target="_blank">sort</a></em>, que utiliza um algoritmo conhecido com <a href="http://pt.wikipedia.org/wiki/Quicksort" onclick="_gaq.push(['_trackEvent', 'outbound-article', 'http://pt.wikipedia.org/wiki/Quicksort', 'Quick Sort']);" title="Quick Sort - wikipedia"  target="_blank">Quick Sort</a> com muitas otimizações em sua implementação. Enfim, o importante é saber que ela ordena um vetor qualquer com complexidade média <strong><span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_f49341ab621f12e8cb93d0146ea51d34.gif' style='vertical-align: middle; border: none; ' class='tex' alt="O(n\log n)" /></span><script type='math/tex'>O(n\log n)</script></strong>. A função <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_cadc8c8db42409733582cb3e2298ef87.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="sort" /></span><script type='math/tex'>sort</script> recebe três parâmetros: um ponteiro para o primeiro elemento a ser ordenado, um ponteiro para o primeiro elemento que não será ordenado e a função que o <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_cadc8c8db42409733582cb3e2298ef87.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="sort" /></span><script type='math/tex'>sort</script> usará para comparação. Em qualquer vetor, seu nome retorna um ponteiro para o elemento da posição 0 e, se somarmos algum inteiro <strong>n</strong> ao nome, teremos um ponteiro para o elemento da posição <strong>n </strong>do vetor. No caso, suponha um vetor de nome <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_c4d9b3f5cbfe7a6a107edbe6648a2d91.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="vetor" /></span><script type='math/tex'>vetor</script>, e que queremos ordenar os elementos que estão entre as posições 1 e <strong>n</strong> (de <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_2bb540781db64e39aaef53e166eda322.gif' style='vertical-align: middle; border: none; ' class='tex' alt="vetor[1]" /></span><script type='math/tex'>vetor[1]</script> a <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_2abf6758eaec700ab297713f7008252e.gif' style='vertical-align: middle; border: none; ' class='tex' alt="vetor[n]" /></span><script type='math/tex'>vetor[n]</script>, inclusive). O ponteiro para o primeiro elemento a ser ordenado é "vetor+1" (que aponta para o elemento <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_2bb540781db64e39aaef53e166eda322.gif' style='vertical-align: middle; border: none; ' class='tex' alt="vetor[1]" /></span><script type='math/tex'>vetor[1]</script>) e o ponteiro para o primeiro elemento que não será ordenado é "vetor+<strong>n</strong>+1" (que aponta para o elemento <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_14b88750dae38a8bf019954a64bb8fd4.gif' style='vertical-align: middle; border: none; ' class='tex' alt="vetor[n+1]" /></span><script type='math/tex'>vetor[n+1]</script>). O terceiro parâmetro da função <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_cadc8c8db42409733582cb3e2298ef87.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="sort" /></span><script type='math/tex'>sort</script> pode ser omitido e, se o for, ela irá comparar o elementos com os operadores "&lt;" e "&gt;". Logo, para ordenar <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_c4d9b3f5cbfe7a6a107edbe6648a2d91.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="vetor" /></span><script type='math/tex'>vetor</script>, da posição 1 à posição <strong>n</strong>, usamos o comando "<strong>sort(vetor+1, vetor+1+n);</strong>". É importante ressaltar também que, como <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_ed469618898d75b149e5c7c4b6a1c415.gif' style='vertical-align: middle; border: none; ' class='tex' alt="algorithm" /></span><script type='math/tex'>algorithm</script> é uma biblioteca do C++, após sua declaração, precisamos escrever o comando "<strong>using namespace std;</strong>", para indicar onde está tal biblioteca. Precisamos escrevê-lo antes de usar as funções da <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_ed469618898d75b149e5c7c4b6a1c415.gif' style='vertical-align: middle; border: none; ' class='tex' alt="algorithm" /></span><script type='math/tex'>algorithm</script>, portanto é bom que o façamos no começo do código, logo após as declarações de bibliotecas e <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_f1edc500eb1136f10c17eeffb9eecbc5.gif' style='vertical-align: middle; border: none; ' class='tex' alt="define" /></span><script type='math/tex'>define</script>'s.</p>
<br />
<p align="justify">A função de comparação, quando declarada como parâmetro, deve ser do tipo <strong>bool </strong>(variável que só guarda 1 bit: <strong>true </strong>ou <strong>false</strong>) receber duas variáveis do tipo das que serão ordenadas e retornar <strong>true</strong> se elas estiverem em ordem (o primeiro parâmetro deve vir antes do segundo na ordenação), e <strong>false</strong> caso contrário (o primeiro parâmetro deve vir depois do segundo, na ordenação). Suponha, por exemplo, que você tem <strong>n</strong> empresas identificadas com números de 1 a <strong>n</strong>, e, no vetor <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_27f08504c8e23c89383aa5ad890892e9.gif' style='vertical-align: middle; border: none; ' class='tex' alt="capital" /></span><script type='math/tex'>capital</script> você guarda os fundos de cada uma. Agora você quer um vetor em que a posições de 1 a <strong>n </strong>guardem as identificações das empresas, ordenadas da mais rica para a mais pobre pelo valor do fundo de cada uma. A primeira coisa a se fazer é criar o vetor com as <strong>n </strong>empresas. Crie um vetor de nome <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_1f3a4258f1161b7ef76e61f3a9396243.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="empr" /></span><script type='math/tex'>empr</script> e use um <strong>for</strong> para preenchê-lo, da posição 1 à posição <strong>n</strong> com todos os números de 1 a <strong>n </strong>("<b>for(int i=1; i&lt;=n; i++) empr[i]=i;</b>"). Antes da main, crie a função <strong>bool compara(int x, int y){}</strong>. Ela receberá dois inteiros <strong>x </strong>e <strong>y</strong> e retornará <strong>true </strong>se <strong>x</strong> deve vir antes de <strong>y</strong> no vetor ordenado e <strong>false</strong>, caso contrário. Como as empresas mais ricas devem vir antes, <strong>x</strong> deverá anteceder <strong>y</strong> se <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_d2a4fe28d3f4c2beac41ad6cb57d3615.gif' style='vertical-align: middle; border: none; ' class='tex' alt="capital[x] \geq capital[y]" /></span><script type='math/tex'>capital[x] \geq capital[y]</script>. Feito tudo isso, para ordenar o vetor <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_1f3a4258f1161b7ef76e61f3a9396243.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="empr" /></span><script type='math/tex'>empr</script>, basta executarmos o comando "<strong>sort(empr+1, empr+n+1, compara);</strong>". A entrada consistirá de duas linha: a primeira terá um inteiro <strong>n</strong>, o número de empresas, e a segunda <strong>n </strong>inteiros: o capital de cada empresa ordenadamente, ou seja, nessa linha, o <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_865c0c0b4ab0e063e5caa3387c1a8741.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="i" /></span><script type='math/tex'>i</script>-ésimo inteiro representa o capital da empresa <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_865c0c0b4ab0e063e5caa3387c1a8741.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="i" /></span><script type='math/tex'>i</script>. A saída deve gerar uma única linha com <strong>n </strong>inteiros: os índices das empresas em ordem decrescente de capital, separados entre si por um espaço em branco. Segue o código do programa:</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/d0a7c7645a23bd80d608.js"></script></p>
<p align="justify">Outro detalhe comum em problemas de ordenação é o desempate. Imagine por exemplo um problema que lhe dá <strong>n</strong>, <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_ad2a0fe23b84b0e07eb59f1b002a8f8e.gif' style='vertical-align: middle; border: none; ' class='tex' alt="1 \leq n \leq 10^5" /></span><script type='math/tex'>1 \leq n \leq 10^5</script>, o número de alunos que participaram de uma prova e, nas próximas <strong>n</strong> linhas lhe dá, em cada linha, o nome do aluno, de no máximo 20 caracteres (todos letras minúsculas), um espaço em branco e a sua nota em uma prova, que é um número decimal. A saída que o programa deve gerar terá <strong>n</strong> linhas, em cada uma o nome de um aluno, ordenados de cima para baixo em ordem decrescente de nota. Ainda mais: em caso de empate de nota, o programa deve imprimir os nomes dos alunos empatados em ordem alfabética.</p>
<br />
<p align="justify">Vamos definir MAXN como 100100 e MAXL como 30. A primeira coisa a ser feita é declarar um vetor <strong>double nota[MAXN]</strong>, que guardará as notas dos alunos e um vetor de strings <strong>char nome[MAXN][MAXL]</strong> (uma matriz de <strong>char</strong>) para guardar os nomes dos alunos. Feito isso, vamos criar um vetor <strong>int aluno[MAXN]</strong>, e colocar nele os números de 1 a <strong>n.</strong>  Agora basta lembrar da <strong>strcmp </strong>para criarmos nossa função de comparação. A função <strong>bool compara(int x, int y)</strong> receberá dois inteiros como parâmetros (os números dos alunos) e deve retornar <strong>true</strong> se o aluno <strong>x</strong> vem antes do <strong>y</strong> e <strong>false</strong>, caso contrário. A primeira coisa a ser verificada é a nota: deve vir antes o aluno de maior nota, o que faremos com os comandos: "<strong>if(nota[x]&gt;nota[y]) return true; if(nota[y]&gt;nota[x]) return false;</strong>". Se a função continuar, então não retornou em nenhum dos dois <strong>if</strong>'s, logo <strong>nota[x]</strong> é igual a <strong>nota[y]</strong>. Então agora devemos comparar os nomes com a função <strong>strcmp</strong>.Lembre-se que ela retorna valor negativo se estiverem em ordem certa e positivo se estiverem em ordem errada. Basta olhar se estão na ordem certa, com o comando: "<strong>if(strcmp(nome[x], nome[y])&lt;0) return true;</strong>", pois se a função passar desse comando e não retornar, então os alunos estão em ordem errada e basta darmos o comando "<strong>return false;</strong>". Agora podemos chamar o <strong>sort</strong> e ordenar o vetor <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_ca0cd09a12abade3bf0777574d9f987f.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="aluno" /></span><script type='math/tex'>aluno</script> e, depois, imprimir o nomes de seus elementos, que já estarão na ordem certa. Segue o código:</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/77c6414c42acf59b8607.js"></script></p>
<p align="justify">Sempre que você precisar ordenar um vetor, ou parte dele, e a complexidade <strong><span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_f49341ab621f12e8cb93d0146ea51d34.gif' style='vertical-align: middle; border: none; ' class='tex' alt="O(n\log n)" /></span><script type='math/tex'>O(n\log n)</script> </strong>passar no tempo, use o <strong>sort</strong> sem medo, ele é simples e eficiente. Isso não significa, entretanto, que você deva esquecer as funções de ordenação que resolveu hoje, pois mesmo que não as use diretamente para ordenar um vetor, as ideias que elas trazem são de extrema importância e ampla aplicação. Problemas de flutuação (troca de elementos consecutivos em uma sequência a fim de que atinjam uma ordem desejada) são geralmente resolvidos com a implementação do Bubble Sort, e a ideia de dividir para conquistar do Merge Sort é muito utilizada em vários problemas.</p>
<br />
<p align="justify">Um problema conhecido é o do número de inversões de um vetor. Contar o número de inversões em um vetor de tamanho <strong>n</strong>, indexado de 1 a <b>n</b>, é encontrar a quantidade de pares <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_3293765967d00230b7f8f3bda30b2cd6.gif' style='vertical-align: middle; border: none; ' class='tex' alt="(i, j)" /></span><script type='math/tex'>(i, j)</script>, com <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_cc5a99832faab4acb568f010f76ea8c5.gif' style='vertical-align: middle; border: none; ' class='tex' alt="1 \leq i < j \leq n" /></span><script type='math/tex'>1 \leq i < j \leq n</script>, de modo que o elemento de índice <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_865c0c0b4ab0e063e5caa3387c1a8741.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="i" /></span><script type='math/tex'>i</script> do vetor é maior que o elemento de índice <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_363b122c528f54df4a0446b6bab05515.gif' style='vertical-align: middle; border: none; ' class='tex' alt="j" /></span><script type='math/tex'>j</script> do vetor. Ou seja, para cada elemento, devemos contar quantos elementos do vetor são menores que ele e estão à sua frente, somar tudo e imprimir a resposta. Como nos problemas de ordenação, a resposta em <strong>O(n²) </strong>é trivial, basta que, para cada elemento, percorramos toda a parte do vetor que está à sua direita em busca de elementos menores que ele ou contemos quantas trocas o Bubble Sort leva para ordenar o vetor. Novamente, esta solução está certa mas é muito ineficiente, e podemos fazer esta conta em <strong><span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_f49341ab621f12e8cb93d0146ea51d34.gif' style='vertical-align: middle; border: none; ' class='tex' alt="O(n\log n)" /></span><script type='math/tex'>O(n\log n)</script></strong>. Você consegue ver qual das ideias vistas hoje melhor se aplica ao problema? Com certeza é a de dividir para conquistar. A função recursiva que resolve este problema difere em pouquíssimas linhas do Merge Sort. Tente resolver o problema. Se não conseguir, segue a resposta explicada, mas realmente tente fazê-lo sozinho antes de lê-la!</p>
<br />
<p align="justify">Para aplicar a ideia de dividir para conquistar, basta dividir um intervalo do vetor ao meio e notar que o número de inversões no intervalo todo é a soma do número de inversões em cada metade do intervalo somado ao número de inversões entre números de metades diferentes. Se ambas as metade estiverem ordenadas, o número de inversões entre elementos de intervalos diferentes fica fácil de ser calculada, bastando que vejamos, para cada índice <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_363b122c528f54df4a0446b6bab05515.gif' style='vertical-align: middle; border: none; ' class='tex' alt="j" /></span><script type='math/tex'>j</script> da metade da direita, o primeiro índice <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_865c0c0b4ab0e063e5caa3387c1a8741.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="i" /></span><script type='math/tex'>i</script> da metade da esquerda que guarda um elemento maior que o elemento <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_363b122c528f54df4a0446b6bab05515.gif' style='vertical-align: middle; border: none; ' class='tex' alt="j" /></span><script type='math/tex'>j</script>, pois estando a metade ordenada, todos os números à direita de <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_865c0c0b4ab0e063e5caa3387c1a8741.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="i" /></span><script type='math/tex'>i</script> serão maiores ou iguais ao elemento <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_865c0c0b4ab0e063e5caa3387c1a8741.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="i" /></span><script type='math/tex'>i</script> e, por consequência, maiores que o elemento <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_363b122c528f54df4a0446b6bab05515.gif' style='vertical-align: middle; border: none; ' class='tex' alt="j" /></span><script type='math/tex'>j</script>.</p>
<br />
<p align="justify">Agora ficou fácil não? Basta fazermos um Merge Sort que retorna um inteiro: o número de inversões no intervalo a ser ordenado. Em um intervalo de um único elemento não há inversões, e a função retornará 0. Se o intervalo tiver mais que um elemento, declaramos a variável <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_a4726e745f0ad12dfe4595700b4172fc.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="invers" /></span><script type='math/tex'>invers</script>, que guardará o número de inversões no intervalo. Ela começará com o valor retornado pelo Merge Sort das duas metades do intervalo (soma das inversões em cada metade). Agora, basta somar a ela as inversões entre posições de metades diferentes. Para isso, quando percorrermos as metades, para juntá-las em um vetor maior, e encontramos um índice <strong>j </strong>da segunda metade com um elemento menor que um elemento de índice <strong>i</strong> da primeira metade, vamos adicionar a <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_a4726e745f0ad12dfe4595700b4172fc.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="invers" /></span><script type='math/tex'>invers</script> o valor de <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_b75b47d0d9d2fe415efdde3b22092496.gif' style='vertical-align: middle; border: none; ' class='tex' alt="((ini+fim)/2-i+1)" /></span><script type='math/tex'>((ini+fim)/2-i+1)</script>, pois como a primeira metade vai até o índice <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_e47aa0d0c6323ab49f668b66f0dbaab8.gif' style='vertical-align: middle; border: none; ' class='tex' alt="(ini+fim)/2" /></span><script type='math/tex'>(ini+fim)/2</script>, esse será o número de elementos à direita do índice <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_865c0c0b4ab0e063e5caa3387c1a8741.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="i" /></span><script type='math/tex'>i</script> (<span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_3bf01d3dc41faa73081467b48bc5f1cb.gif' style='vertical-align: middle; border: none; ' class='tex' alt="(ini+fim)/2-i" /></span><script type='math/tex'>(ini+fim)/2-i</script>), que serão inversões, somando ainda a inversão com o próprio <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_865c0c0b4ab0e063e5caa3387c1a8741.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="i" /></span><script type='math/tex'>i</script> (por isso o +1). Segue o código para melhor entendimento:</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/92d3dcb0db3ccc112e66.js"></script></p>

