<p align="justify"> <strong>Autor: </strong> Rogério Júnior </p>
<p align="justify"> <strong>Fonte: </strong> <a href="noic.com.br">Noic</a> </p>

<h1>2.1 - Pilha e Fila</h1>

<h2> Indice </h2>
<ol>
<li> <a href="#pilha"> Pilha </a></li>
<li> <a href="#fila"> Fila </a></li>
<li> <a href="#struct"> Structs </a></li>
</ol>

<br />
<a name="pilha"></a>
<p align="justify">Até agora vimos estruturas de dados simples, como vetores e matrizes. Nesta aula, vamos aprender a usar um vetor e alguma variáveis  auxiliares para construirmos estruturas de dados mais complexas.</p>
<h3>Pilha</h3>
<p align="justify">A primeira estrutura que vamos ver é a <a href="http://pt.wikipedia.org/wiki/Pilha_(inform%C3%A1tica)" onclick="_gaq.push(['_trackEvent', 'outbound-article', 'http://pt.wikipedia.org/wiki/Pilha_(inform%C3%A1tica)', 'pilha']);" title="Pilha"  target="_blank">pilha</a>, pois só precisa de uma única variável auxiliar. Em uma pilha, o último elemento inserido é o primeiro a sair e, para implementar essa estrutura em C, só precisamos de um vetor e uma varável inteira <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_3eaf6c984c18d143e1c0a797779afea8.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="tam" /></span><script type='math/tex'>tam</script> que guardará o tamanho do vetor. Uma pilha tem a função "<strong>push</strong>", que coloca um elemento no topo da pilha, a função "<strong>pop</strong>", que retira o elemento do topo da pilha, a função <strong>top</strong>, que diz qual é o elemento no topo e a <strong>clear</strong>, que tira todos os elementos da pilha. Para implementarmos as funções vamos logo declarar as variáveis que usaremos. Vamos definir que o tamanho máximo da pilha, <b>MAXT</b>, será 1000100. Vamos criar uma pilha de inteiros e, para isso, vamos declarar o vetor "<strong>int pilha[MAXT];</strong>" e a variável "<strong>int tam;</strong>". Declare <strong>tam</strong> global para que ela comece com o valor zero. Vamos indexar o vetor <strong>pilha</strong> de 1 a n, assim, o elemento do topo sempre será "<strong>pilha[tam]</strong>". Para excluir o elemento do topo, basta que façamos a redução da variável <strong>tam</strong> em 1 unidade, pois agora, seu tamanho realmente será uma unidade maior e o termo "<strong>pilha[tam]</strong>" agora se refere a um elemento uma posição atrás do antigo topo, que é o que ocorre quando tiramos o topo de uma pilha: o novo topo será o elemento abaixo do antigo. Para inserirmos o elemento <strong>x</strong> na pilha, basta que aumentemos <strong>tam </strong>em 1 unidade, com o comando "<strong>tam++;</strong>", e depois façamos o topo da pilha receber <strong>x</strong>, com o comando "<strong>pilha[tam]=x;</strong>". Para limparmos a pilha, basta zerarmos a variável <strong>tam</strong>, com o comando "<strong>tam=0;</strong>".</p>
<br />
<p align="justify">É bom saber que podemos reduzir esses dois comando a uma única linha: "<strong>pilha[++tam]=x;</strong>". Note que como o operador "++" vem antes de "<strong>tam</strong>", primeiro o computador adiciona 1 unidade a <strong>tam</strong> e depois realiza o comando "<strong>pilha[tam]=x;</strong>". Se invertermos a ordem e escrevermos "<strong>pilha[tam++]=x;</strong>", primeiro o computador irá executar o comando "<strong>pilha[tam]=x;</strong>" e só então o comando "<strong>tam++;</strong>". Essa regra de precedência de operadores se aplica em qualquer ocasião. Escrever "<strong>int n = i++;</strong>" irá fazer primeiro <strong>n</strong> receber o valor de <strong>i</strong> para só então aumentar <strong>i</strong> em uma unidade. O comando "<strong>int n = ++i;</strong>" aumentará primeiro o valor de <strong>i</strong> para só então fazer <strong>n</strong> receber seu valor.</p>
<br />
<p align="justify">Segue um código com uma pilha e suas três funções já implementadas. Note que, por precaução, a função <strong>pop</strong> só elimina o topo da pilha se houver algum elemento nela (<strong>tam</strong> &gt; 0), para que não corramos o risco de ter uma pilha com tamanho negativo:</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/68bb3ed87e4813ea8c81.js"></script></p>
<p align="justify">Agora que você já sabe implementar um pilha, tente resolver o problema <a href="https://www.urionlinejudge.com.br/judge/pt/problems/view/1062" onclick="_gaq.push(['_trackEvent', 'outbound-article', 'https://www.urionlinejudge.com.br/judge/pt/problems/view/1062', 'Trilhos']);" title="Trilhos"  target="_blank">Trilhos</a>. Se não conseguir, segue a solução explicada, mas realmente tente fazê-lo sozinho antes de lê-la.</p>
<br />
<p align="justify">Note que quando os vagões entram na estação, ficam todos enfileirados em cima dos trilhos, e apenas o último vagão que entrou tem liberdade para sair, ou seja, é como se empilhássemos os vagões. Para resolver o problema basta que façamos um <strong>for</strong> que quer percorrerá toda a sequência dos vagões que devem sair, que estará salva no vetor <strong>saida</strong>. Olhando qual o próximo vagão que deve sair, verifico se ele está no topo da pilha. Se ele não estiver, vou empilhando os vagões que ainda faltam entrar, até que chegue o vagão esperado. Quando o vagão chega, eu o tiro da pilha (dou um <strong>pop</strong>), passo para o próximo vagão que deve sair e continuo o algoritmo. Se em algum momento eu precisar empilhar mais um vagão e não houver mais nenhum esperando para entrar, então é impossível que eles saiam na ordem desejada. Segue o código para melhor entendimento. Vale lembrar que o operador "<strong>!</strong>" representa negação, ou seja, (<strong>!condicao</strong>) retorna o oposto de <strong>condicao</strong>: se <strong>condicao </strong>for verdadeira, <strong>!condicao </strong>seria falsa, e vice-versa.</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/13518db338ce3bb15051.js"></script></p>

<a name="fila"></a>
<h3>Fila</h3>
<p align="justify">Agora que você já viu como funciona uma pilha, pense em como implementar um <a href="http://pt.wikipedia.org/wiki/Estrutura_de_dados#Fila" onclick="_gaq.push(['_trackEvent', 'outbound-article', 'http://pt.wikipedia.org/wiki/Estrutura_de_dados#Fila', 'fila']);" title="Fila - wikiepedia"  target="_blank">fila</a>. Em uma fila, o primeiro que entra é o primeiro que sai, ou seja, na fila a função <strong>push</strong> não coloca um novo elemento no topo, como na pilha, mas no final da fila. A função <strong>pop</strong> não tira o último elemento que foi inserido, mas o que está na fila há mais tempo. Não temos a função <strong>top</strong>, mas as funções <strong>front</strong>, que retorna o primeiro elemento na fila, e <strong>back</strong>, que retorna o último elemento da fila. Como não teremos mais a variável <strong>tam</strong>, podemos implementar, também, a função <strong>size</strong>, que retorna o tamanho da fila. Para implementar a fila, precisarmos novamente de um vetor que a guardará, que chamaremos de <strong>fila</strong>, e as variáveis inteiras <strong>ini</strong> e <strong>fim</strong>, que guardam em qual índice do vetor estão o primeiro e o último elemento da fila, respectivamente. É fácil ver que a função <strong>front </strong>deve retornar <strong>fila[ini]</strong> e a função <strong>back</strong> deve retornar <strong>fila[last]</strong>. A função <strong>pop</strong> deve excluir o elemento do começo, fazendo com que o próximo elemento da fila se torne o primeiro, logo, ela deve aumentar o valor de <strong>ini</strong> em uma unidade. A função <strong>push</strong> deve receber o elemento <strong>x</strong>, que será inserido, e então aumentar o tamanho da fila, fazendo com que seu fim seja uma posição depois da que ele era ("<strong>fim++;</strong>") e lá colocar o valor a ser inserido ("<strong>fila[fim]=x;</strong>"). Logo, ela deve realizar o comando "<strong>fila[++fim]=x;</strong>". O tamanho da fila será o a quantidade de elementos entre <strong>ini </strong>e <strong>fim</strong>, ou seja, deve retornar <b>fim-ini+1</b>. Note que a fila deve começar com <strong>ini=1 </strong>e <strong>fim=0</strong>, para que todas as funções funcionem com os comandos aqui mostrados, logo, para zerarmos a fila, basta fazermos essas duas variáveis assumirem esses valores. Segue um código com a implementação de uma fila de inteiros. Note que a função <strong>pop</strong> só retira o elemento se ele estiver lá (<strong>size()&gt;0</strong>), para não corrermos o risco de termos uma fila de tamanho negativo. Na implementação, definimos o tamanho máximo da fila, novamente, como 1000100.</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/ba4cb6ed4a408738f9ef.js"></script></p>
<p align="justify">Agora que você já sabe implementar um pilha, tente resolver o problema <a href="https://www.urionlinejudge.com.br/judge/pt/problems/view/1110" onclick="_gaq.push(['_trackEvent', 'outbound-article', 'https://www.urionlinejudge.com.br/judge/pt/problems/view/1110', 'Jogando Cartas Fora']);" title="Jogando Cartas Fora"  target="_blank">Jogando Cartas Fora</a>. Se não conseguir, segue a solução explicada, mas realmente tente fazê-lo sozinho antes de lê-la.</p>
<br />
<p align="justify">A pilha de cartas será representada por uma fila, pois as cartas são inseridas no fim dela (primeira que entra é a primeira que sai). A primeira coisa a se fazer é limpar a fila ("<strong>clear();</strong>") e inserir nela, ordenadamente, todas as cartas de 1 a <strong>n</strong>, com um <strong>for</strong>: ("<strong>for(int i=1; i&lt;=n; i++) push(i);</strong>"). No começo da saída vamos imprimir a linha "Discarded Cards:". Vamos abrir um <strong>while</strong> que rodará enquanto ainda houver duas ou mais cartas na fila ("<strong>size()&gt;=2</strong>"). Agora, dentro do loop, basta que façamos estritamente o que manda o problema: vamos imprimir a carta que está em cima do monte (a primeira da fila, pois foi a primeira a ser inserida) precedida de espaço em branco, com o comando "<strong>printf(" %d", front());</strong>"; depois retiramos essa carta da fila ("<strong>pop();</strong>"); depois colocamos a nova carta que está no topo na parte de trás da fila ("<strong>push(front());</strong>") e, novamente, a tiremos do começo da fila. Por fim, se inda houver mais de uma carta na fila ("<strong>if(size()&gt;=2)</strong>") imprima a vírgula que separa os números. No fim de cada caso de teste, imprimiremos, em outra linha, a carta que ficou na pilha, seguida da quebra de linha, com o comando "<strong>printf("\nRemaining card: %d\n", front());</strong>". Segue o código para melhor entendimento:</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/500bd6296bda8e4bf733.js"></script></p>
<p align="justify">Um ponto a ser ressaltado, em filas e pilhas e em qualquer outro programa é que chamar uma função é um pouco lento. Até agora, realmente implementei as funções das filas e pilhas, mas somente por ser mais didático que vejamos as chamadas das funções <strong>push</strong>, <strong>pop</strong>, <strong>size</strong>, ... mas é muito melhor simplesmente executar, na linha em que chamávamos a função, o comando que ela realiza ao invés de chamá-la. É mais rápido, por exemplo, usar o comando "<strong>tam--;</strong>" em uma pilha do que o comando "<strong>pop;</strong>". Para melhor compreensão, segue o código do problema anterior sem a implementação das funções da fila:</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/ce06b47641261ad2d186.js"></script></p>
<p align="justify">Agora que você já sabe tudo iss, tente fazer o problema <a href="http://olimpiada.ic.unicamp.br/pratique/programacao/nivel2/2012f2p2_banco" onclick="_gaq.push(['_trackEvent', 'outbound-article', 'http://olimpiada.ic.unicamp.br/pratique/programacao/nivel2/2012f2p2_banco', 'Banco']);" title="Banco"  target="_blank">Banco</a>. Se não conseguir, segue a resposta abaixo, mas realmente tente fazê-lo sozinho antes de lê-la.</p>
<br />
<p align="justify">Este é um problema da segunda fase da P2 da OBI 2012, mas precisaremos apenas de uma fila e três vetores auxiliares para resolvê-lo. Vamos definir <strong>MAXC</strong> como o limite de <strong>c</strong>, <strong>MAXN</strong> como o limite de <strong>n</strong> e <strong>MAXF</strong> como o tempo máximo que o banco levará para finalizar todos os atendimentos (o número máximo de pessoas multiplicado pelo tempo máximo de atendimento e somado ao instante máximo de chegada (<strong>1000 x 10 + 300 = 10300</strong>)). Como <b>MAXF </b>é pequeno (<span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_79bbf4ac48c7a4158867dfbf61dfa98d.gif' style='vertical-align: middle; border: none; ' class='tex' alt="MAXF << 10^6" /></span><script type='math/tex'>MAXF << 10^6</script>), podemos declará-lo com sobra e definir <strong>MAXF</strong> como 20000. O dois primeiros vetores auxiliares que vamos precisar são o <strong>int chegada[MAXN]</strong>, que guardará o minuto em que cada pessoa da fila chegou (a pessoa <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_865c0c0b4ab0e063e5caa3387c1a8741.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="i" /></span><script type='math/tex'>i</script> chega no minuto <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_8ddfe3b9f8c8c93b156c7687a4cffc57.gif' style='vertical-align: middle; border: none; ' class='tex' alt="chegada[i]" /></span><script type='math/tex'>chegada[i]</script>), e o <strong>int tempo[MAXN]</strong>, que guardará a duração do atendimento de cada pessoa (o atendimento da pessoa <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_865c0c0b4ab0e063e5caa3387c1a8741.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="i" /></span><script type='math/tex'>i</script> terá duração de <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_545487e494ce9f7f9ad6442e4e6a5b63.gif' style='vertical-align: middle; border: none; ' class='tex' alt="tempo[i]" /></span><script type='math/tex'>tempo[i]</script> minutos). O terceiro é o <strong>int livre[MAXC]</strong>, que vai guardar em qual minuto cada caixa vai ficar livre (o caixa <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_865c0c0b4ab0e063e5caa3387c1a8741.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="i" /></span><script type='math/tex'>i</script> ficará livre no instante <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_a71c41ee4cb3dd1bdac2b55d1fa8ba77.gif' style='vertical-align: middle; border: none; ' class='tex' alt="livre[i]" /></span><script type='math/tex'>livre[i]</script>). Vamos guardar também uma variável auxiliar <strong>prox</strong> que guarda qual é a próxima pessoa que vai entrar na fila e a variável <strong>resposta</strong>, que guardará quantas pessoas vão esperar mais de 20 min na fila. No começo do programa vamos preencher os vetores <strong>chegada </strong>e<strong> tempo</strong> com as informações da entrada, indexando-os de 1 a <strong>n</strong>. O vetor <strong>livre</strong> deve ter todos os seus valores zerados (podemos declará-lo como global, por exemplo) pois, no começo, todos os caixas estarão livres no tempo 0. O valor de <strong>prox</strong> será 1, pois a primeira pessoa será a próxima a entrar na fila.</p>
<br />
<p align="justify">Para simular o andamento da fila, usaremos um <strong>for</strong> que representará a passagem do tempo, fazendo uma variável <strong>min</strong> variar de 0 até o tempo máximo que o banco levará para atender todos os clientes (<strong>MAXF</strong>). Para cada repetição do <strong>for</strong>, vamos simular o que acontece durante o minuto <strong>min</strong>. Vamos olhar quem é a próxima pessoa que vai chegar ao banco (<strong>prox</strong>) e verificar se ela já chega neste minuto, ou seja, se <strong>chegada[prox]==min</strong>. Se for, a insiro na fila com a função <strong>push</strong> e digo que a próxima pessoa que chegará será <strong>prox+1 </strong>(comando "<strong>prox++;</strong>"). Se <strong>prox</strong> for maior que <strong>n</strong>, então já chegaram todas as pessoas e não devo inserir ninguém. Vamos usar um <strong>while</strong> para repetir essa operação até que todas as pessoas que chegarão no minuto <strong>min</strong> entrem na fila. Feito isso, vou verificar se tem alguém na fila. Se tiver, vou procurar se já tem algum caixa vago, ou seja, percorrerei o vetor <strong>livre</strong> em busca de um caixa <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_865c0c0b4ab0e063e5caa3387c1a8741.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="i" /></span><script type='math/tex'>i</script> que está ficando livre agora ou que já ficou livre em um tempo anterior (<strong>livre[i]&lt;=min</strong>). Se houver caixa livre, então essa pessoa será atendida, então devo olhar o tempo que ela esperou, que será o minuto atual subtraído do minuto em que ela chegou (<strong>min - chegada[front()]</strong>). Se esse tempo de espera for maior que 20 min, então adiciono uma pessoa a <strong>resposta </strong>(<strong>resposta++</strong>). Além disso, o instante em que o caixa <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_865c0c0b4ab0e063e5caa3387c1a8741.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="i" /></span><script type='math/tex'>i</script>, que irá atender esse cliente, ficará livre será o minuto atual somado da duração do atendimento do cliente ("<strong>livre[i]=tempo[front()];</strong>"). Feito isso, vamos tirar a primeira pessoa da fila com o comando "<strong>pop();</strong>" e executar o comando "<strong>break;</strong>" para sairmos do <strong>for q</strong>ue procurava um caixa livre. Novamente, usaremos um <strong>while</strong> para repetir o procedimento de atender uma pessoa enquanto houver caixas livres. Para isso, usaremos uma <strong>bool vaga</strong>, que indicará se há algum caixa vago. Ela sempre começará <strong>false</strong>, mas, se após percorrermos o vetor <b>livre</b> encontrarmos algum caixa vago, ela receberá <strong>true</strong>, fazendo com que ela somente termine o <strong>while</strong> como <strong>false</strong> se tivermos percorrido todos os caixas e nenhum deles estiver livre. Vale lembrar que se não houver ninguém mais na fila ("<strong>if(size()==0)</strong>") e ninguém mais for chegar ao banco ("<strong>if(prox&gt;n)</strong>"), podemos acabar o <strong>for </strong>agora com um <strong>break</strong>, executando o comando "<strong>if(size()==0 &amp;&amp; prox&gt;n) break;</strong>". Ao final do programa, imprimimos o valor de resposta, seguido da quebra de linha. Segue o código para melhor entendimento. Note que nele não há a implementação das funções, mas apenas os comandos que elas devem executar.</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/8f78b7219c853a6b8e83.js"></script></p>
<a name="struct"></a>
<h3>Criando sua própria estrutura</h3>
<p align="justify">Até agora você usou variáveis e funções apenas de tipos já salvos no C++, como <strong>int</strong>, <strong>double</strong>, <strong>char </strong>e <strong>bool</strong>. Entretanto, a linguagem permite que você crie o seu próprio "tipo", a sua própria <strong>struct</strong>. Uma <strong>struct</strong> é um objeto como outro qualquer, com suas próprios objetos salvos. Para declarar uma <strong>struct </strong>de nome <strong>objeto</strong>, usamos o comando "<strong>struct objeto{};</strong>". Entre as chaves, escrevemos os membros  de <strong>objeto</strong>. Se quisermos, por exemplo, que <strong>objeto</strong> tenha duas variáveis, o <strong>int a </strong>e o <strong>int b</strong>, escrevemos isso entre as chaves, da forma: "<strong>struct objeto{ int a, b; };</strong>". Lembre-se que <b>objeto</b> não é o nome de uma variável, mas de um tipo, como <strong>int </strong>ou <strong>char</strong>, por exemplo. Ou seja, vamos declarar uma variável do tipo <strong>objeto</strong>. Ela teria que ter um nome assim como se fôssemos declarar uma do tipo <strong>int</strong>. Para declararmos a variável <strong>var </strong>do tipo <strong>objeto</strong>, usamos o mesmo comando que usaríamos em qualquer outro tipo: "<strong>objeto var;</strong>". Agora temos uma variável de nome <strong>var</strong> e do tipo <strong>objeto</strong>. Vamos, então, declarar a <strong>struct </strong>assim:</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/923c9c4f900e16ae6bb7.js"></script></p>
<p align="justify">Como faço para acessar um membro de uma <strong>struct</strong>? Escrevo o nome da variável do tipo que criei (no caso <strong>var</strong>) seguido de um ponto (".") e então escrevo o nome do membro.  Se quiséssemos acessar o valor de <strong>a</strong> do objeto <strong>var</strong>, escreveríamos "<strong>var.a</strong>". Se já tivermos declarado o objeto <strong>var</strong> e escrevermos os comandos "<strong>var.a=3; var.b=4;</strong>", então o valor da variável <strong>a</strong> de <strong>var</strong> receberá 3 e o de <strong>b</strong> receberá 4. Como atribuímos 4 ao valor de <strong>b</strong>, o comando "<strong>printf("%d", var.b);</strong>" imprimiria o inteiro 4 na tela.</p>
<br />
<p align="justify">Podemos usar uma <strong>struct </strong>para representar objetos que são definidos por mais de um valor, inclusive de tipos diferentes. Um ponto, por exemplo, no plano cartesiano, é determinado por dois valores: os das suas coordenadas x e y, respectivamente. Logo, poderíamos representá-lo como uma <strong>struct </strong>que contêm duas <strong>doubles</strong>, o <strong>coord_x</strong> e o <strong>coord_y</strong>. Veja:</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/8adcbd3f2ac18186c8a2.js"></script></p>
<p align="justify">Um aluno, por exemplo, pode ser representado por seu nome (um vetor de <strong>char</strong>) e sua nota (uma <strong>double</strong>). Veja:</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/705f02f1c338a6b061f0.js"></script></p>
<p align="justify">Assim como em qualquer outro tipo, podemos declarar um vetor de uma <strong>struct</strong>.<strong> </strong>Para representar uma sala de aula, por exemplo, posso criar um vetor de <strong>aluno</strong> de 100 posições de nome <strong>classe</strong>, com o comando "<strong>aluno classe[100];</strong>". Para ordená-lo, posso usar a função <strong>sort</strong>, desde que use uma função de comparação para que o <strong>sort</strong> saiba ordenar os alunos, que será feita exatamente como vimos na <a title="Aula 5 - Ordenação" href="http://noic.com.br/informatica/curso-noic-de-informatica/aula-5-ordenacao/" target="_blank">aula de ordenação</a>. Agora, entretanto, não acessaremos os elementos em um outro vetor, todos serão membros de um mesmo elemento do vetor <strong>classe</strong>. Além disso, a função de comparação não mais receberá inteiros como identificadores do alunos, para depois procurar os seus atributod, mas receberá estruturas que, sozinhas, contêm todos os dados dos estudantes: o tipo <strong>aluno</strong>. Segue o código para melhor compreensão:</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/7e6166dce78a33b86f9c.js"></script></p>

