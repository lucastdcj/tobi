<p align="justify"> <strong>Autor: </strong> Rogério Júnior </p>
<p align="justify"> <strong>Fonte: </strong> <a href="noic.com.br">Noic</a> </p>

<h1>3.3 - Busca Binária</h1>

<p align="justify">Imagine o seguinte problema: dado um vetor ordenado de <strong>n</strong> números distintos, faça um programa que responde a <strong>m</strong> perguntas do tipo: "o número <strong>x</strong> está no vetor?". A primeira linha terá dois inteiros: os valores de <strong>n </strong>e <strong>m</strong>, respectivamente. A segunda linha terá <strong>n</strong> inteiros ordenados: os elementos do vetor. A terceira e última linha terá <strong>m</strong> inteiros. Para cada um desses números, seu programa deve gerar uma linha na saída. Se o número não estiver no vetor, a linha deve ter o valor "-1". Caso ele esteja, ela deve imprimir a posição do número no vetor (indexado de 1 a <strong>n</strong>).</p>
<br />
<p align="justify">Segue um exemplo de entrada e saída:</p>
<p align="justify">Entrada:</p>
<p align="justify">7 4</p>
<p align="justify">-2 0 4 7 8 9 11</p>
<p align="justify">5 -2 7 15</p>
<p align="justify">Saída:</p>
<p align="justify">-1</p>
<p align="justify">1</p>
<p align="justify">4</p>
<p align="justify">-1</p>
<p align="justify">Tal problema parece ser bem simples: basta que percorramos o vetor inteiro com um <strong>for</strong>, procurado o número lido. Porém, percorrer o vetor tem complexidade <strong>O(n)</strong>, e esta operação será executada <strong>m</strong> vezes, o que gera uma complexidade de <strong>O(n*m)</strong>. E se as únicas restrições do problema forem: <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_1a489090dd39993efece3d4d5c415315.gif' style='vertical-align: middle; border: none; ' class='tex' alt="1\leq n, m \leq 10^5" /></span><script type='math/tex'>1\leq n, m \leq 10^5</script>? A complexidade será <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_1f7bffbdbf84ad7bb6c4d2e769a16072.gif' style='vertical-align: middle; border: none; ' class='tex' alt="O(10^{10})" /></span><script type='math/tex'>O(10^{10})</script>, o que com certeza iria ultrapassar o tempo máximo de execução. Como fazer para verificar se um número está em um vetor ordenado de maneira mais eficiente?</p>
<br />
<p align="justify">Esse problema é semelhante a procurarmos uma palavra em um dicionário de <strong>n</strong> páginas, supondo que basta achar a página. A primeira ideia que tivemos foi folhear, uma a uma, todas as páginas do dicionário, começando da primeira até a última, procurando a palavra. Nos piores casos, teremos que olhar todas as páginas do dicionário. Note que tal mecanismo de busca funcionaria com a mesma eficiência se as palavras do dicionário estivessem em ordem aleatória, ou seja, não estamos usando a nosso favor o fato de as palavras estarem ordenadas. Essa ordenação só nos trás uma vantagem: quando vemos que uma palavra não está em determinada página, sabemos, pela ordem alfabética, se ela, estando no dicionário, estará antes ou depois daquela página, o que elimina todas as outras opções. Assim, vamos tentar eliminar o máximo possível de páginas logo na primeira consulta ao dicionário: basta que o abramos bem no meio! Desse modo, se a palavra estiver lá, que bom que encontramos, se não, não importa se a palavra estará antes ou depois da página do meio, eliminarei metade das consultas que teria que fazer a cada uma das páginas da metade em que a palavra não se encontra. Agora, na metade que restou do dicionário, aplico o mesmo processo, até que só reste uma possibilidade de página em que a palavra pode estar: se ela lá estiver, achei a página, se não, ela não pode estar no dicionário!</p>
<br />
<p align="justify">E qual a complexidade desse algoritmo? Iremos repetir o processo de dividir o número de páginas possíveis ao meio até que reste somente uma página, logo, sendo <strong>c</strong> o número de vezes que vou consultar o dicionário temos que: <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_98c7311564ca8095e76028528af53c6a.gif' style='vertical-align: middle; border: none; ' class='tex' alt="\frac{n}{2^c} = 1\Leftrightarrow n = 2^c\Leftrightarrow \log{n} = \log{2^c} = c \log{2} = c\Leftrightarrow c = \log{n}" /></span><script type='math/tex'>\frac{n}{2^c} = 1\Leftrightarrow n = 2^c\Leftrightarrow \log{n} = \log{2^c} = c \log{2} = c\Leftrightarrow c = \log{n}</script>, logo a complexidade de uma busca é <strong>O(log n)</strong>. Desse modo, realizando <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_396a8c0267f4feffdaadf71c2911d8bc.gif' style='vertical-align: middle; border: none; ' class='tex' alt="10^5" /></span><script type='math/tex'>10^5</script> operações de complexidade <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_028d6f4055a97a199a7977d43c9622b6.gif' style='vertical-align: middle; border: none; ' class='tex' alt="O(\log{10^5})" /></span><script type='math/tex'>O(\log{10^5})</script>, teremos uma complexidade final de <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_b61ee31ef5d7e25296449a5bfe30be0e.gif' style='vertical-align: middle; border: none; ' class='tex' alt="O(10^6)" /></span><script type='math/tex'>O(10^6)</script>, o que certamente passa no tempo. Basta gora que implementemos a função que realiza essa busca eficiente no vetor, que é conhecida como busca binária.</p>
<br />
<p align="justify">Vamos declarar o array de inteiros de nome <strong>vetor</strong>, que guardará os inteiros ordenados. Agora, vamos declarar a função "<strong>int buscab(int x){}</strong>", que irá retornar a posição de <strong>x</strong> em vetor, ou -1 se ele não estiver no array. A função começará declarando três variáveis: <strong>int ini</strong>, <strong>int fim</strong> e <strong>int meio</strong>, que guardarão o começo, o fim e o meio do intervalo que vamos analisar, respectivamente. O valor inicial de <strong>ini</strong> será 1 e o de <strong>fim </strong>será <strong>n</strong>, pois no começo o número pode estar em qualquer posição do vetor. Ela terá um <strong>while</strong> que repetirá o algoritmo enquanto o intervalo tiver pelo menos um número (<strong>ini&lt;=fim</strong>). A ideia é atribuir a <strong>meio</strong> o elemento mais ou menos na metade do intervalo (<strong>meio=(ini+fim)/2;</strong>) e verificar se o número do meio (<strong>vetor[meio]</strong>) é o que procuramos. Se ele for, retornamos o valor de meio. Se procuramos um número menor que o do meio, então agora devemos olhar, na próxima repetição do <strong>while</strong>, apenas para o intervalo compreendido entre <strong>ini</strong> e <strong>meio-1</strong>, pois é onde ele deve estar. Para isso, fazemos <strong>fim</strong> receber o valor <strong>meio-1</strong>. Se procuramos um número maior, olhamos, de maneira análoga, para o intervalo compreendido entre <strong>meio+1</strong> e <strong>fim</strong>, com o comando "<strong>ini=meio+1;</strong>". Se o <strong>while</strong> terminar e a função ainda não tiver retornado nada, então o número não está no vetor e retornamos o valor <strong>-1</strong>. Vale lembrar que os comando aqui usados só são corretos se o vetor estiver indexado de <strong>1</strong> a <strong>n</strong>, correndo o risco de entrar em loop infinito caso haja a posição 0.</p>
<Br />
<p align="justify">Segue o código que resolve o problema acima com a função <strong>buscab</strong>, para melhor entendimento:</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/5598f30cebdb236d23e2.js"></script></p>
<p align="justify">A implementação de uma busca binária é conhecida por ter pequenos bugs que quase nunca identificamos, o que a faria entrar em algum loop infinito. Enfim, o código aqui mostrado funciona bem, mas, caso você esqueça algum detalhe, algumas pessoas gostam de colocar um contador dentro do loop que impede que o número de repetições do <strong>while</strong> passe de 35, por exemplo, visto que o log do maior valor que cabe em um <strong>int </strong>é 32, evitando o loop infinito.</p>
<br />
<p align="justify">Vale notar também que a ideia da busca binária não se restringe somente a sequências crescentes, mas a qualquer intervalo em que, buscando determinado elemento, olho para alguma posição do intervalo e sei se ele está antes ou se está depois de tal posição. Certa vez me deparei com um problema em que parte dele consistia em identificar, em <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_293089b84708ceec3debafb55e35eebf.gif' style='vertical-align: middle; border: none; ' class='tex' alt="O(\log{n})" /></span><script type='math/tex'>O(\log{n})</script>, o maior elemento de um vetor de inteiros positivos que crescia até certo elemento, que era o máximo, e a partir de então começava a decrescer. Segue um exemplo de vetor assim, de 7 elementos:</p>
<p align="justify">1 3 4 5 6 4 3</p>
<p align="justify">É fácil ver que o elemento é o procurado (o máximo) se o anterior a ele for menor ou igual que ele e o posterior for menor. No caso, 6 é antecedido de 5 e sucedido por 4. Vamos aplicar a busca binária: checar se o número do meio é o maior é checar se seu antecessor é menor que ele e seu sucessor também ("<strong>if(vetor[meio-1]&lt;vetor[meio] &amp;&amp; vetor[meior+1]&lt;vetor[meio])</strong>"). Se isso ocorrer, retornamos o valor salvo em "<strong>vetor[meio]</strong>". Note que para a função não dar problema no começo e no fim do vetor, as posições 0 e <strong>n+1 </strong>devem estar declaradas (<strong>n </strong>é o número de elementos), e guardarem o inteiro 0, pois ele é menor que todos os elementos do vetor, não quebrando, portanto, sua lógica de ser crescente e depois decrescente, mas nunca serão acessados pela busca binária. Caso o número do meio não seja o maior, olhamos se seu sucessor é menor que ele. Se for, então já estamos na parte do vetor que decresce, e devemos olhar apenas para a metade atrás da posição <strong>meio </strong>("<strong>if(vetor[meio+1]&lt;vetor[meio]) fim=meio-1;</strong>"). Se o sucessor for maior, então ainda estamos na parte que cresce, e devemos olhar a metade depois da posição <strong>meio</strong> ("<strong>if(vetor[meio+1]&gt;vetor[meio]) ini=meio+1;</strong>"). Segue a implementação dessa busca binária:</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/5d0d68c87b74cc601784.js"></script></p>
<p align="justify">Note que, em alguns problemas podemos usar a busca binária em um vetor ordenado com números de 1 a <strong>n</strong> para chutarmos a sua resposta (<strong>n</strong> é a resposta máxima) e depois testarmos se ela é válida. Imagine que queremos um inteiro <strong>resp</strong> mínimo que resolve o problema e todos os outros maiores que ele também resolvem, mas buscamos o menor. Suponha também que testar um número como resposta leva tempo <strong>O(n)</strong>. Se fôssemos testar um por um todos os números, do menor para o maior, a complexidade seria <strong>n*O(n) = O(n²)</strong>. Mas se usarmos a busca binária para procurarmos a resposta, buscando o primeiro número que funciona, só usaríamos <strong>log n</strong> consultas, o que daria uma complexidade de <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_e2357327a56e2af6536c18de1747e21c.gif' style='vertical-align: middle; border: none; ' class='tex' alt="O(n \log{n})" /></span><script type='math/tex'>O(n \log{n})</script>.</p>
<br />
<p align="justify">O código seria bem simples: testo se o número do meio do intervalo funciona. Se ele funcionar, o guardo em alguma variável, e procuro um menor que ele que também funcione, com busca binária, olhando agora para a metade do intervalo que está antes do meio. Se o número não funcionar, então a resposta é maior que ele e devo procurar a na metade do intervalo que vem depois do meio. Segue, para exemplo, a implementação de uma busca binária que encontra, em <strong>log n</strong>, o primeiro número de um vetor ordenado <strong>int vetor[100100]</strong>, que é maior ou igual a um <strong>int x</strong>.</p>
<style>.gist table { margin-bottom: 0; }</style>

