<p align="justify"> <strong>Autor: </strong> Rogério Júnior </p>
<p align="justify"> <strong>Fonte: </strong> <a href="noic.com.br">Noic</a> </p>

<h1>2.2 - Set e Map</h1>

<h2> Indice </h2>
<ol>
<li> <a href="#set"> Set </a></li>
<li> <a href="#map"> Map </a></li>
</ol>

<p align="justify">Foi dito no início do curso que usaríamos o C++ como linguagem de programação, mas até agora só usamos uma função própria dele: o <strong>sort</strong>. É recomendado que você implemente suas próprias estruturas de dados, como foi ensinado com pilhas e filas, mas nem todas são tão fáceis de implementar. Hoje mostraremos algumas estruturas bem mais complicadas de fazer, como a <a href="http://pt.wikipedia.org/wiki/%C3%81rvore_AVL" onclick="_gaq.push(['_trackEvent', 'outbound-article', 'http://pt.wikipedia.org/wiki/%C3%81rvore_AVL', 'árvore AVL']);" title="AVL - Wikipedia"  target="_blank">árvore AVL</a>, mas que possuem funções muito simples e eficientes de serem usadas, com implementação já pronta em C++, que no caso da AVL é o <a href="http://www.cplusplus.com/reference/set/set/" onclick="_gaq.push(['_trackEvent', 'outbound-article', 'http://www.cplusplus.com/reference/set/set/', 'set']);" title="Set - Cplusplus"  target="_blank">set</a>.</p>
<a name="set"></a>
<h3>Conjunto</h3>
<p align="justify">Agora imagine o seguinte problema: você começa com um conjunto vazio e serão feitas <strong>n</strong> operações. Cada operação pode ser adicionar, retirar, ou perguntar se algum elemento está no conjunto, que é formado por inteiros de 1 até <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_0e57800c01e7644dc1ceefedbdfb37f7.gif' style='vertical-align: middle; border: none; ' class='tex' alt="10^9" /></span><script type='math/tex'>10^9</script>. A entrada terá na primeira linha o valor de <strong>n</strong>. Cada uma das próximas <strong>n</strong> linhas terá dois inteiros <strong>t</strong> e <b>x</b>, que irão descrever uma operação. O primeiro número (<strong>t</strong>) irá indicar o tipo de operação a ser realizada. Se <strong>t=1</strong>, devemos adicionar <strong>x</strong> ao conjunto. Se <strong>t=2</strong>, devemos retirar <strong>x</strong> do conjunto. Adicionar um número que já pertence ao conjunto, ou retirar um que não pertence a ele equivale a não fazer nada. Se <strong>t=3</strong>, então devemos imprimir uma única linha, que terá o caractere 'S', caso <strong>x</strong> pertença ao conjunto, ou 'N', caso contrário. Segue um exemplo de entrada:</p>
<p align="justify">6</p>
<p align="justify">1 3</p>
<p align="justify">1 4</p>
<p align="justify">3 3</p>
<p align="justify">2 4</p>
<p align="justify">3 4</p>
<p align="justify">3 6</p>
<p align="justify">Essa entrada descreve as seguintes 6 operações: primeiro adiciono o elemento 3 ao conjunto, depois adiciono o 4. Na terceira linha, pergunto se 3 está no conjunto, e ele está, logo devo imprimir uma linha com o caractere 'S'. Na quarta linha, retiro o elemento 4, deixando o conjunto apenas com o 3. Na quinta, pergunto se o 4 está no conjunto, e, como ele não está, devo imprimir o caractere 'N' em uma linha. Na última operação da entrada, pergunto se o 6 está no conjunto. Ele nunca este e apenas imprimo o caractere 'N'. Logo, a saída esperada é:</p>
<p align="justify">S</p>
<p align="justify">N</p>
<p align="justify">N</p>
<p align="justify">Cada linha correspondendo, ordenadamente, a cada uma das perguntas feitas na entrada.</p>
<br />
<p align="justify">Talvez você lembre que nas primeiras aulas usamos um vetor para implementar um conjunto. Se o elemento <strong>i</strong> estava no conjunto, então <strong>vetor[i]</strong> era 1. Se ele não estava, era 0. Para isso, entretanto, é necessário que usemos um vetor do tamanho do maior número possível da entrada, para acessar seu estado (se está ou não no conjunto). Vemos, infelizmente, que o maior número possível nesse caso é <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_0e57800c01e7644dc1ceefedbdfb37f7.gif' style='vertical-align: middle; border: none; ' class='tex' alt="10^9" /></span><script type='math/tex'>10^9</script>, e um vetor desse tamanho é muito grande para ser declarado, o compilador não deixará que tal programa seja feito. A primeira coisa que pensamos talvez fosse criar um vetor que vai guardando os elementos do conjunto e um inteiro com seu tamanho. Assim, toda vez que adicionamos um elemento, vamos adicionar esse número ao fim do vetor, para retirá-lo, basta percorrer o vetor e colocar um 0 em todas as posições em que o número aparece. Para checar se ele está no vetor, basta percorrê-lo, procurando alguma posição com o número. Segue um código que implementa as funções <strong>insert</strong>, que insere um número no conjunto, <strong>erase</strong>, que apaga um número do conjunto e <b>count</b>, que retorna <strong>1</strong> se o número estiver no conjunto e <strong>0</strong> caso contrário, e as usa para resolver o problema. Lembre-se que apenas implemento as funções por motivos didáticos e é mais rápido simplesmente executar seus comandos no código. Lembre que em C++ apenas 0 significa <strong>false</strong>, qualquer outro valor é visto como condição verdadeira, no <strong>if</strong> por exemplo.</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/288d63edca3ab2985558.js"></script></p>
<p align="justify">Apesar de imprimir a resposta certa, esse código é extremamente ineficiente. Observe a complexidade das funções: duas delas percorrem completamente o vetor, que pode até ter tamanho <strong>n</strong>, o que gera complexidade <strong>O(n)</strong>. Como vamos executar <strong>n</strong> operações, a complexidade é <strong>O(n²)</strong> (aproximação bem por cima). Assim, resolveríamos o problema para <strong>n</strong> próximo de <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_8591947ab747b35b6c49905385d9d116.gif' style='vertical-align: middle; border: none; ' class='tex' alt="10^3" /></span><script type='math/tex'>10^3</script>, mas, e se <strong>n</strong> fosse <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_396a8c0267f4feffdaadf71c2911d8bc.gif' style='vertical-align: middle; border: none; ' class='tex' alt="10^5" /></span><script type='math/tex'>10^5</script>? Para isso, vamos usar o <strong>set</strong>, uma estrutura já implementada no C++ que simula um conjunto, sem repetição de elementos. Ele está na biblioteca <strong>set</strong>, do C++. Para declararmos um conjunto com nome <strong>conj</strong>, de variáveis do tipo <strong>tipo</strong><strong>1</strong>, usamos o comando "<strong>set&lt;tipo1&gt; conj;</strong>". Logo, para o problema, vamos criar um conjunto de mesmo nome, mas que guardará variáveis inteiras, com o coando "<strong>set&lt;int&gt; conj;</strong>". Um <strong>set</strong> tem como membros as funções <strong>insert</strong>, <strong>erase </strong>e<strong> count</strong> já implementadas. Ou seja, assim como usamos o nome da estrutura seguido de ponto seguido do nome do membro de uma <strong>struct </strong>para acessá-lo, usaremos, por exemplo, os comandos "<strong>conj.insert(x);</strong>" para inserir o elemento <strong>x</strong> em <strong>conj</strong>, "<strong>conj.erase(x)</strong>" para apagar <strong>x</strong> e "<strong>conj.count(x);</strong>" para verificar se <strong>x</strong> pertence ao conjunto. O diferencial do <strong>set</strong> é que cada uma dessas funções tem complexidade O(<span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_0d2e858bd7f89eed5461e5637d6e0a50.gif' style='vertical-align: middle; border: none; ' class='tex' alt="\log n" /></span><script type='math/tex'>\log n</script>), onde <strong>n</strong> é o tamanho do conjunto. Segue a solução do problema usando <strong>set</strong>.</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/4ba8ac6dc447725a45e3.js"></script></p>
<p align="justify">Antes de passarmos para o próximo tópico, vamos falar bem rapidamente de ponteiros, visto que até agora já usamos algumas vezes esse nome. Um ponteiro é um tipo de variável como outra qualquer, mas seu valor guarda o endereço de outra variável na memória do computador. Já dissemos, por exemplo, que quando chamamos o nome de uma string, ela retorna um ponteiro para o seu primeiro caractere, ou seja, ela retorna seu endereço. Já vimos também que o <strong>sort</strong> recebe ponteiros como parâmetros. Enfim, ponteiro é simplesmente o endereço, a localização da variável no meio da memória do computador. Para declararmos um ponteiro, escrevemos o tipo de elemento que ele aponta, seguido de um asterisco, seguido do nome do ponteiro. Para declarar, por exemplo, o ponteiro <strong>ptr</strong>, que deve guardar o endereço de um <strong>int</strong>, usamos o comando "<strong>int * ptr;</strong>". Para vermos o endereço de uma variável já declarada, usamos o operador "<strong>&amp;</strong>" antes de seu nome. Se quisermos, por exemplo, declarar um <strong>int a</strong> e fazer com que <strong>ptr</strong> aponte para ele, usamos o comando "<strong>ptr = &amp;a;</strong>". Para acessarmos o elemento que um ponteiro está apontando, usamos o operador "*" antes de seu nome. Se quisermos, por exemplo, declarar um outro <strong>int b</strong> e fazê-lo receber o valor que <strong>ptr</strong> aponta, usaríamos o comando "<strong>int b= *ptr;</strong>". Para imprimir esse valor salvo em <strong>ptr</strong>, usaríamos novamente o "*" no comando "<strong>printf("%d", *ptr)</strong>;".</p>
<br />
<p align="justify">Todos os elementos de um vetor são salvos lado a lado, por isso quando adicionamos 1 a um ponteiro para algum de seus elementos, estamos apontando para o próximo. Cada tipo de variável consome seu próprio espaço: um<strong> int</strong> consome <strong>4 bytes</strong>, um <strong>char 1 byte</strong>, o que faz com que, na verdade, um vetor de <strong>int</strong> posicione seus elementos a 4 bytes de distância um do outro, mas o operador "+" de ponteiros já sabe o tipo que ele aponta e conserta isso, fazendo com que ele sempre avance quantas posições eu queira. O nome de um vetor, inclusive uma <strong>string</strong>, sempre retorna um ponteiro para a primeira posição. De modo geral, um ponteiro para qualquer variável retorna um ponteiro para seu primeiro <strong>byte</strong>. Repito ainda que um ponteiro é um tipo de variável como outra qualquer, e pode ser usada, por exemplo como parâmetro e retorno de funções, como será feito a seguir.</p>
<br />
<p align="justify">Suponha agora que você terá <strong>n</strong> operações  apenas de inserção e exclusão de um conjunto e, ao final da entrada, seu programa deva imprimir todos os números do conjunto, ordenadamente, um por linha. Como fazemos para acessar todos os elementos de um <strong>set</strong>? Primeiro, o <strong>set </strong>consegue fazer todas aquelas operações em tempo tão rápido porque ele guarda seu elementos de maneira "ordenada". Entretanto, a ordem não é como a de um vetor, onde todos os elementos estão um do lado do outro em um espaço de memória, em ordem crescente, mas de uma maneira bem mais complexa. Por isso, o <strong>set</strong> tem um <strong>iterator </strong>(iterador). Ele é um tipo de objeto que recebe um ponteiro e "sabe" percorrer os elementos de um <strong>set</strong> na ordem crescente. Assim, se temos um <strong>iterator</strong> de nome<strong> it </strong>e executarmos o comando "<strong>it++;</strong>", ele agora apontará para o próximo elemento do <strong>set</strong>, em ordem crescente. Para percorrer todos o <strong>set</strong>, basta usarmos um <strong>for</strong> e um iterador que começará apontando para o primeiro elemento do conjunto e, enquanto ele não apontar para o fim do <strong>set</strong>, iremos para o próximo elemento. Vale ressaltar que para declarar um <strong>iterator </strong>de nome <strong>it</strong>, por exemplo, precisamos antes especificar que tipo de<strong> </strong>iterador ele será, especificando a estrutura de dados <strong>structure</strong> que ele deve percorrer e o tipo de objeto <strong>tipo1</strong> que estará salvo naquela estrutura, com o comando "<strong>structure&lt;tipo1&gt;::iterator it;</strong>". No caso, precisamos de um que saiba percorrer um <strong>set</strong> de inteiros, logo escreveremos o comando "<strong>set&lt;int&gt;::iterator it;</strong>", para criar este tipo de iterador. Além disso, precisamos saber que a função <strong>begin()</strong>, do <strong>set</strong>, retorna um ponteiro para o primeiro elemento do conjunto, e a função <strong>end() </strong>retorna um ponteiro para seu final. Sabendo isso, o programa que resolve o problema enunciado usando um <strong>set</strong> para guardar os elementos do conjunto seria assim:</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/eb193a8437208896085a.js"></script></p>
<p align="justify">Além das 5 funções que já vimos, o set tem muitas outras, dentre elas as mais importantes são:</p>
<p align="justify"><strong>size() </strong>-  retorna um inteiro: a quantidade de elementos no <strong>set</strong> em <strong>O(1)</strong></p>
<p align="justify"><strong>clear() </strong>- apaga todos os elementos do <strong>set</strong> em <strong>O(size)</strong></p>
<p align="justify"><strong>empty() </strong>- retorna <strong>true</strong> se o <strong>set</strong> estiver vazio e <strong>false</strong> caso contrário, em <strong>O(1)</strong></p>
<p align="justify"><strong>find(x) </strong>- retorna um ponteiro para um elemento igual a <strong>x</strong> no <strong>set </strong>em <strong>O(log(size))</strong>. Se não houver tal elemento, retorna um ponteiro para o fim do <strong>set</strong>.</p>
<p align="justify"><strong>lower_bound(x) </strong>- retorna, em <strong>O(log(size))</strong>, um ponteiro para o primeiro elemento do <strong>set</strong>, em ordem crescente, que não é menor que <strong>x</strong>.</p>
<p align="justify"><strong>upper_bound(x) </strong>- retorna, em <strong>O(log(size))</strong>, um ponteiro para o primeiro elemento do <strong>set</strong>, em ordem crescente, que é maior que <strong>x</strong>.</p>
<p align="justify">As três últimas funções serão mais utilizadas em algoritmos futuros, e você só precisa se concentrar, agora, nas três primeiras. Para ver uma lista completa dos membros de um <strong>s</strong><strong>et</strong>, clique <a href="http://www.cplusplus.com/reference/set/set/" onclick="_gaq.push(['_trackEvent', 'outbound-article', 'http://www.cplusplus.com/reference/set/set/', 'aqui']);" title="Set - cplusplus"  target="_blank">aqui</a> e veja a página dele na referência do <a href="http://www.cplusplus.com/" onclick="_gaq.push(['_trackEvent', 'outbound-article', 'http://www.cplusplus.com/', 'Cplusplus']);" title="Cplusplus"  target="_blank">Cplusplus</a>.</p>
<br />
<p align="justify">Sempre é bom lembrar, também, que o <strong>multiset</strong> está na biblioteca <strong>set</strong> e faz tudo o que um conjunto normal faz, sendo declarado do mesmo jeito, mas aceita repetição de elementos. Além disso, vale notar que, em problemas que pprecisam de mais de um conjunto, podemos criar um vetor de <strong>set</strong> assim como criarmos um vetor de qualquer outra estrutura, e acessar os <strong>set</strong>'s em suas posições de maneira análoga a qualquer outro vetor. Para criarmos um vetor de <strong>set&lt;int&gt; </strong>de 10 posições, com o nome <strong>conj</strong>, usaríamos o comando "<strong>set&lt;int&gt; conj[10];</strong>", e para acessar o i-ésimo <strong>set</strong>, usaríamos "<strong>conj[i]</strong>". Ou seja, para inserirmos o número 4 no <strong>set</strong> da posição 6 do vetor <strong>conj</strong>, usaríamos o comando "<strong>conj[6].insert(4);</strong>".</p>
<a name="map"></a>
<p align="justify"><strong>Map</strong></p>
<p align="justify">Imagine o seguinte problema: dados <strong>n</strong> pagamentos que Daniboy realizou de algumas contas (ele pode ter dividido algumas contas em mais de um pagamento), imprima quanto foi pago em cada tipo de conta. A primeira linha terá o valor de <strong>n</strong> e as próximas <strong>n</strong> linhas terão, cada uma, uma <strong>string s</strong>, a conta que Daniboy estava pagando, e a <strong>double v</strong>, o valor que foi pago na conta. A conta a ser paga pode ser repetida em algumas linhas, visto que ele podia não pagar tudo de uma vez, e o valor final que foi pago nessa conta será a soma de todos os pagamentos referentes a ela. O programa deve gerar uma linha para cada tipo de conta, contendo o nome dela e o valor total pago, com uma precisão de duas casas após a vírgula, ordenando-as em ordem alfabética. Exemplo de entrada:</p>
<p align="justify">5</p>
<p align="justify">imposto 8570.62</p>
<p align="justify">cartao 54.50</p>
<p align="justify">agua 23.50</p>
<p align="justify">cartao 132.20</p>
<p align="justify">energia 172.80</p>
<p align="justify">Daniboy fez 5 pagamentos em 4 tipos diferentes de contas.Ele dividiu a conta de "cartao" em dois pagamentos, um de R$ 132,20 e outro de R$ 54,50, o que totaliza um pagamento de R$ 186,70. A saída deve ter 4 linhas, uma para cada tipo de conta, em ordem alfabética, contendo o seu nome e o valor total nela pago, separados por um espaço em branco. Exemplo:</p>
<p align="justify">agua 23.50</p>
<p align="justify">cartao 186.70</p>
<p align="justify">energia 172.80</p>
<p align="justify">imposto 8570.62</p>
<p align="justify">Se as contas fossem identificadas por inteiros, não por nomes, bastaríamos que fizéssemos um vetor de <strong>double</strong> que guardava quanto foi pago em cada conta e depois imprimíssemos os seus índices seguidos dos valores neles salvos. Para acessar um elemento salvo em um vetor normal, usamos o inteiro que identifica a qual posição estamos nos referindo, ou seja, a chave para uma posição no vetor é um inteiro. Felizmente, existe o <strong>map</strong>. Ele é uma estrutura de dados já implementada no C++ que simula um vetor em que as posições são identificadas por uma chave que pode ser qualquer tipo de variável, não somente por inteiros. O único custo é que acessar uma posição dele custa <strong>O(log n)</strong> (onde <strong>n</strong> é o tamanho do vetor), ao invés do <strong>O(1) </strong>de um vetor normal. Ele está na biblioteca <strong>map</strong>, do C++, e é declarado de maneira semelhante às outras estruturas vistas hoje. Se quisermos declarar um <strong>map</strong> de nome <strong>mapa</strong>, que simulará um vetor em que as chaves de suas posições são objetos do tipo <strong>tipo1</strong> e cada uma delas guardará um um objeto do tipo <strong>tipo2</strong>, usamos o comando "<strong>map&lt;tipo1, tipo2&gt; mapa;</strong>". No caso, queremos criar um <strong>map</strong> de nome <strong>mapa </strong>que simule um vetor em que as posições são <strong>strings</strong>, e, como não podemos usar um vetor como tipo, teremos que usar a <strong>string</strong> ao invés da <strong>cstring</strong>. Além disso, queremos que cada posição do vetor guarde uma <strong>double </strong>(o valor total pago naquela conta), logo usaremos o comando "<strong>map&lt;string, double&gt; mapa;</strong>". Para criarmos ou acessarmos a posição <strong>frase</strong> (onde <strong>frase</strong> é uma <strong>string</strong>) do vetor <strong>mapa</strong>, usamos "<strong>mapa[frase]</strong>". Vale ressaltar que, se já existir a posição <strong>frase</strong>, o comando "<strong>mapa[frase]=x;</strong>" atribui a ela o valor de <strong>x</strong>, mas se ela ainda não tiver sido criada, ele a cria e depois atribui a ela tal valor.</p>
<br />
<p align="justify">O <strong>map </strong>tem uma função importante chamada <strong>find</strong>. Como estamos em <strong>mapa</strong>, se chamarmos a função "<strong>mapa.find("agua");</strong>", ela retornaria um ponteiro para o elemento salvo em <strong>mapa na chave</strong> "agua". Se não existir tal chave, ela retornará um ponteiro para o fim de <strong>mapa</strong>.</p>
<br />
<p align="justify">Assim, para cada pagamento efetuado por Daniboy, vamos escanear o nome da conta e salvá-lo na <strong>string </strong><strong>conta</strong>, e o valor pago, salvando-o na <strong>double valor</strong>. Depois vamos verificar se a posição de nome <strong>conta </strong>já existe no vetor simulado por <strong>mapa</strong>. Para fazer isso, vamos ver se a função "<strong>mapa.find(conta)</strong>" retorna um ponteiro diferente de fim do <strong>mapa</strong>. Vale ressaltar que, assim como no <strong>set</strong>, o <strong>map</strong> também tem as funções <strong>begin()</strong> e <strong>end()</strong>, que retornam ponteiros para o começo e para o fim do <strong>map</strong>, respectivamente. Assim, verificar se uma chave, já existe é verificar: "<strong>if(mapa.find(conta)!=mapa.end())</strong>". Se isso ocorrer, adiciono <strong>valor</strong> ao elemento salvo na chave <strong>conta</strong>, com o comando "<strong>mapa[conta]+=valor;</strong>". Caso contrário, crio a chave <strong>conta </strong>e nela salvo o valor pago, que está em <strong>valor</strong>, através do comando "<b>mapa[conta]=valor;</b>".</p>
<br />
<p align="justify">Quando tivermos lido toda a entrada, cada chave do <strong>mapa</strong> representará o nome de uma <strong>conta</strong> e terá nela salvo o valor a ser pago. Agora basta que percorramos todo o <strong>mapa</strong> imprimindo, para cada um de seus elementos, o nome da chave e do valor nela salvo. Para isso, assim como no <strong>set</strong>, vamos usar um iterador que saiba percorrer um <strong>map</strong>. Semelhante ao <strong>set</strong>, essa estrutura<strong> </strong>ordena seus elementos em ordem crescente de chave. Logo, as posições, que são <strong>strings</strong>, estarão em ordem alfabética, o que nos permitirá imprimir as contas nessa ordem, como pedido pelo problema. Para declará-lo, fazemos algo semelhante ao que fizemos no <strong>set</strong>, indicando que tipo de iterador queremos criar e, depois, seu nome. Queremos declarar um iterador de nome <strong>it</strong> que saiba percorrer um <strong>map</strong> onde as chaves são <strong>strings</strong> e que guarda elementos do tipo <strong>double</strong>, logo usamos o comando "<strong>map&lt;string, double&gt;::iterator it;</strong>". Vamos fazer um <strong>for </strong>para que <strong>it</strong> percorra todos os elementos de <strong>mapa</strong>. Porém, <strong>it</strong> aponta para os dois valores: a chave e o elemento nele salvo. Logo, para acessar a chave, o primeiro elemento, chamo o membro <strong>first</strong> ("<b>(*it).first</b>"), e para ver o segundo elemento, o valor nele salvo, chamo o membro <strong>second</strong> ("<strong>(*it).second</strong>"). Assim, dentro do <strong>for</strong>, vamos imprimir a chave com o comando "<strong>cout &lt;&lt; (*it).first</strong>". Agora teremos que imprimir o valor salvo na posição usando o <strong>printf</strong>, pois queremos a <strong>double </strong>com apenas duas casas de precisão, usando o comando "<strong>printf(" %.2lf\n", (*it).second);</strong>", para também imprimir o espaço em branco entre o nome e o valor e depois a quebra de linha. Segue o código para melhor entendimento:</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/584c077fbfccea2a103b.js"></script></p>
<p align="justify">Além das mostradas nessa aula, o <strong>map </strong>tem várias outras funções, que podem ser vistas na referência do <a href="http://www.cplusplus.com/reference/map/map/" onclick="_gaq.push(['_trackEvent', 'outbound-article', 'http://www.cplusplus.com/reference/map/map/', 'Cplusplus']);" title="Map - cplusplus"  target="_blank">Cplusplus</a>. Dentre elas, as mais importantes são:</p>
<br />
<p align="justify"><strong>size() -</strong> retorna, em <b>O(1)</b>, o número de posições no <strong>map</strong></p>
<p align="justify"><strong>erase(x) </strong>- apaga, em <strong>O(1)</strong>, a posição determinada pela chave <strong>x</strong></p>
<p align="justify"><strong>clear() </strong>- apaga todos os elementos do <strong>map</strong> em <strong>O(size)</strong></p>
<p align="justify">Vale lembrar que todas as funções mostradas na aula de hoje são membros de alguma estrutura, ou seja, para chamá-las, precisamos escrever o nome do objeto que declaramos, seguido de um ponto ".", seguido do nome da função e seus parâmetros.</p>
<br />
<p align="justify">Existem outras estruturas já implementadas no C++, sendo as mostrada hoje apenas as necessárias para PJ e P1 da OBI com implementação já pronta. Para ver todas as estruturas da STL, veja a <a href="http://www.cplusplus.com/reference/stl/" onclick="_gaq.push(['_trackEvent', 'outbound-article', 'http://www.cplusplus.com/reference/stl/', 'referência do Cplusplus']);" title="Containers - Cplusplus"  target="_blank">referência do Cplusplus</a>.</p>

