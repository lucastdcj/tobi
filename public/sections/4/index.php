<p align="justify"> <strong>Autor: </strong> Rogério Júnior </p>
<p align="justify"> <strong>Fonte: </strong> <a href="noic.com.br">Noic</a> </p>

<h1>1.4 - Vetores e Matrizes</h1>

<p align="justify">Imagine um problema bem simples: imprimir uma sequência de números de trás para frente. A entrada consiste de duas linha. Na primeira, haverá um inteiro <strong>n</strong> (<span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_d888ce575891ffa41c7d21713cb70b0b.gif' style='vertical-align: middle; border: none; ' class='tex' alt="1\leq" /></span><script type='math/tex'>1\leq</script><strong>n</strong><span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_1f19a7da1d31bac102469063299a6481.gif' style='vertical-align: middle; border: none; ' class='tex' alt="\leq 10^6" /></span><script type='math/tex'>\leq 10^6</script>)<strong> </strong>e, na segunda, um sequência de <strong>n</strong> números inteiros separados por um espaço em branco. A saída deve gerar uma única linha: Os <strong>n</strong> números da sequência lida, mas de trás para frente</p>
<br /> 
<p align="justify">Você já deve ter percebido que vamos precisar salvar esses números, visto que não poderemos imprimí-los na ordem em que aparecem. Porém, como declarar <strong>n</strong> variáveis se não conheço o valor de <strong>n</strong>? A resposta é criando um vetor. Um vetor (ou um array, são sinônimos) é como uma sequência de variáveis em que posso acessá-las pelo índice.</p>
<p style="text-align: center;"><a href="http://noic.com.br/wp-content/uploads/2015/04/vetor_image1.png"><img class="aligncenter wp-image-3363 size-full" src="http://noic.com.br/wp-content/uploads/2015/04/vetor_image1.png" alt="vetor_image" width="493" height="113" /></a></p>
<br />
<p align="justify">Para criar um vetor, escrevo seu tipo, seu nome, e, em seguida, quantas variáveis ele vai guardar, entre colchetes "[]". Para declarar um vetor de inteiros com o nome <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_8e2e3b74f717c5487cc478fd3831a113.gif' style='vertical-align: middle; border: none; ' class='tex' alt="sequencia" /></span><script type='math/tex'>sequencia</script> para guardar 10 posições, por exemplo, escreveria o comando: "<strong>int sequencia[10];</strong>". Assim, o computador guarda, na sua memória, o espaço para guardar 10 inteiros. Para me referir ao elemento de índice 5 deste vetor, por exemplo imprimí-lo, eu o chamaria pelo índice, escrevendo "<strong>printf("%d", sequencia[5]);</strong>". Para ler um número na tela e guardá-lo no índice 5 do vetor, faria um comando análogo: "<strong>scanf("%d", &amp;sequencia[5]);</strong>". Vale lembrar que, como mostrado na figura acima, se o vetor tem <strong>n</strong> posições, ele estará indexado de 0 a <strong>n-1</strong>, ou seja, o primeiro elemento será o sequencia[0], o segundo será o sequencia[1] e o último será o sequencia[n-1]. No caso, como declaramos um vetor de 10 posições, teremos os índices de 0 té 9. Para não marcar os elementos um por um, podemos dizer quais são os elementos de um vetor logo na sua declaração, através do comando "={}". Escrever, por exemplo, "<strong>int vetor[5]={0, 1, 4, 9, 16};</strong>" significa declarar um vetor de inteiros de 5 posições cujo nome é <strong>vetor </strong>e, onde a posição 0 do vetor receberá 0, a posição 1 receberá 1, a 2 receberá 4,  a 3 receberá 9 e a 4 receberá 16.</p>
<br />
<p align="justify">Geralmente usamos um <strong>for</strong> para percorrer todas as casas do vetor, fazendo um inteiro <strong>i</strong> ser o índice que quero acessar e fazendo-o variar entre as posições do vetor que desejo percorrer. Agora ficou fácil fazer o problema do início, não? Vamos declarar um vetor de <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_677a6aa1054db67a51077dc95295daa1.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="1000100" /></span><script type='math/tex'>1000100</script> posições, (pois <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_4899fb44f14867ddc63aa25d835c547f.gif' style='vertical-align: middle; border: none; ' class='tex' alt="10^6" /></span><script type='math/tex'>10^6</script> é o valor máximo de <strong>n</strong> e sobra sempre é bom) e, usando um <strong>for</strong> que irá de 1 até<strong> n</strong>, vou salvar os números lidos na tela nas posições de 1 a <strong>n. </strong>Feito isso usaremos um <strong>for</strong> que vai de <strong>n</strong> até 1 para percorrer o vetor de trás para frente e imprimir os números nele salvo. Vamos ao código:</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/44515b61ccc674969fdc.js"></script></p>
<p align="justify">Agora que você já sabe fazer o básico de vetores, tente fazer o problema <a href="https://www.urionlinejudge.com.br/judge/pt/problems/view/1105" onclick="_gaq.push(['_trackEvent', 'outbound-article', 'https://www.urionlinejudge.com.br/judge/pt/problems/view/1105', 'Sub-Prime']);" title="Sub-Prime"  target="_blank">Sub-Prime</a>. Se  não conseguir, segue a solução comentada abaixo abaixo, mas realmente tente resolvê-lo antes de lê-la!</p>
<br />
<p align="justify">O uso de vetor neste caso será para guardarmos o fundo monetário que cada banco possui. No começo, vamos declarar um vetor de nome <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_55096af6ec94acc9afb0eb81f74cb729.gif' style='vertical-align: middle; border: none; ' class='tex' alt="fundo" /></span><script type='math/tex'>fundo</script> de 30 posições, pois são no máximo 20 bancos e, no começo de cada caso de teste, salvaremos o fundo do banco de número <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_865c0c0b4ab0e063e5caa3387c1a8741.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="i" /></span><script type='math/tex'>i</script> na posição <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_865c0c0b4ab0e063e5caa3387c1a8741.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="i" /></span><script type='math/tex'>i</script> do vetor. Antes veja que usaremos o <strong>break</strong> para finalizar a leitura quando ocorrer o fim de entrada (<strong>n</strong> e <strong>b</strong> forem zero). Agora que temos salvos os fundos de cada banco, vamos abrir um for que se repetirá <strong>n</strong> vezes e, a cada repetição, executará uma operação de debênture. No caso, essa operação consiste em ler os valores do banco devedor <strong>d</strong>, do credor <strong>c</strong> e do valor de transferência <strong>v</strong>, subtrair o valor de <strong>v</strong> do fundo do banco devedor ("<strong>fundo[d]-=v;</strong>") e adicionar este valor ao fundo do banco credor ("<strong>fundo[c]+=v;</strong>"). Após realizarmos todas as operações, vamos verificar se algum banco precisa de ajuda financeira. Vamos declarar uma variável <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_3c06b7e68d6e8c356099d91f89328650.gif' style='vertical-align: middle; border: none; ' class='tex' alt="ajuda" /></span><script type='math/tex'>ajuda</script> que começará com o valor 0. Vamos usar um <strong>for</strong> para olharmos todas as posições do vetor <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_55096af6ec94acc9afb0eb81f74cb729.gif' style='vertical-align: middle; border: none; ' class='tex' alt="fundo" /></span><script type='math/tex'>fundo</script> e, se em alguma delas o valor estiver negativo, significa que este banco terminou endividado e precisará de ajuda, logo <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_3c06b7e68d6e8c356099d91f89328650.gif' style='vertical-align: middle; border: none; ' class='tex' alt="ajuda" /></span><script type='math/tex'>ajuda</script> receberá 1. Terminada a verificação, se o valor de <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_3c06b7e68d6e8c356099d91f89328650.gif' style='vertical-align: middle; border: none; ' class='tex' alt="ajuda" /></span><script type='math/tex'>ajuda</script> ainda for zero, nenhum banco precisou de auxílio financeiro e então imprimiremos "S". Caso contrário, então algum banco está com fundo negativo e precisará de dinheiro, e imprimiremos "N". Segue o código:</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/a15b8d731f72bdf656ae.js"></script></p>
<p align="justify">Até agora, vimos um vetor de inteiros. Um tipo de vetor muito conhecido é o vetor de caracteres, que é uma frase. O vetor de variáveis do tipo <strong>char</strong> é declarado de maneira semelhante ao de inteiros. Ele tem um nome especial: <strong>string.</strong> Para escanearmos uma <strong>string</strong> com o <strong>scanf</strong>, usamos o indicador <strong>%s</strong> e não colocamos o "&amp;" antes do nome da <strong>string</strong>, pois seu nome já é um ponteiro para o começo do vetor. Para ler uma frase e salvá-la em uma <strong>string</strong> de nome <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_18341ec4b96d60e29c5bf6bdbe42fdbb.gif' style='vertical-align: middle; border: none; ' class='tex' alt="frase" /></span><script type='math/tex'>frase</script>, escrevemos o comando: "<strong>scanf("%s", frase);</strong>". Vale lembrar que <strong>%s</strong> significa "leia até um espaço", ou seja, só será salva a frase até o primeiro espaço ou quebra de linha. Se na entrada estiver escrito "Alan Turing", ficaria salvo em <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_18341ec4b96d60e29c5bf6bdbe42fdbb.gif' style='vertical-align: middle; border: none; ' class='tex' alt="frase" /></span><script type='math/tex'>frase</script> apenas o nome "Alan", pois o <strong>scanf</strong> iria parar no espaço em branco entre as duas palavras. Além disso, é importante saber que o final de uma <strong>string</strong> é marcado pelo caractere '\0'. Ou seja, <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_18341ec4b96d60e29c5bf6bdbe42fdbb.gif' style='vertical-align: middle; border: none; ' class='tex' alt="frase" /></span><script type='math/tex'>frase</script> seria uma <strong>string </strong>de comprimento 4, mas teria 5 caracteres salvos: frase[0]='A', frase[1]='l', frase[2]='a', frase[3]='n' e frase[4]='\0'. A leitura já coloca o '\0' no fim da string automaticamente.</p>
<br />
<p align="justify">Assim como aspas simples representam caractere, aspas duplas representam <strong>string</strong>. Se quisermos fazer com que <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_18341ec4b96d60e29c5bf6bdbe42fdbb.gif' style='vertical-align: middle; border: none; ' class='tex' alt="frase" /></span><script type='math/tex'>frase</script> receba a frase "Alan Turing", escrevemos o comando "<strong>frase="Alan Turing;</strong>"; Um '\0' seria automaticamente adicionado na posição 12, no final da <strong>string</strong>.</p>
<br />
<p align="justify">Há algumas maneiras de explicar ao <strong>scanf</strong> o que queremos que ele leia para formar uma <strong>string</strong>, se quisermos algo diferente de simplesmente ler até o primeiro espaço. Se ao invés de <strong>%s </strong>escrevermos <b>%[]</b>, podemos colocar entre os colchetes os tipos de caracteres que queremos. Seja <strong>c</strong> um caractere qualquer, se escrevemos "<b>%[^c]</b>" a função irá ler toda a entrada até que apareça o primeiro caractere igual ao <strong>char c </strong>e ignorar o resto da frase (ignoraria, inclusive, o caractere <strong>c</strong>). Para lermos uma linha toda até o fim e salvarmos na <strong>string </strong><strong>frase</strong>, escrevemos o comando "<strong>scanf("%[^\n]", frase);</strong>", que irá ler até o caractere quebra de linha ('\n'). Se <strong>a,</strong> <strong>b</strong> e <strong>c </strong>forem caracteres, escrever "<b>%[abc]</b>" fará a função ler todos os caracteres até o primeiro que não seja <strong>a</strong>, <strong>b </strong>ou <strong>c</strong>. Podemos ligar caracteres através de "-" para indicar um conjunto, ou seja: "<b>%[a-cek]</b>" irá fazer a função ler até o primeiro caractere que não tenha código entre <strong>a </strong>e <strong>c</strong> (inclusive), ou <strong>e</strong> ou <strong>k</strong>. Exemplo: o comando  "<strong>scanf("%[a-z A-Z]", frase);</strong>" iria ler até o primeiro caractere que não esteja entre 'a' e 'z', ou entre 'A' e 'Z' ou não seja espaço em branco (pois ele aparece entre o <b>z</b> e o <b>A</b>), ou seja, iria ler letras minúsculas, maiúsculas e espaços em branco.</p>
<br />
<p align="justify">Segue o código de um programa que lê uma frase de até 29 caracteres até o primeiro caractere que não seja uma letra ou um espaço em branco e depois imprime esta frase seguida de um ponto e quebra de linha:</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/499d84cd153b97652d11.js"></script></p>
<p align="justify">Existem algumas funções próprias para uma <strong>string</strong>. Elas estão na biblioteca <a href="http://www.cplusplus.com/reference/cstring/" onclick="_gaq.push(['_trackEvent', 'outbound-article', 'http://www.cplusplus.com/reference/cstring/', 'cstring ou string.h']);" title="cstring"  target="_blank"><strong>cstring </strong>ou <strong>string.h</strong></a>. Dentre várias, são mais importantes:</p>
<br />
<p align="justify">obs* saiba que o <strong>string</strong> nomeia um tipo que não é o vetor de char que estamos vendo, mas uma estrutura de C++ muito parecida que estudaremos depois. Para efeito didático, nesta página, vamos usar<strong> string</strong> para nomear o tipo "vetor de char" nas seguintes funções:</p>
<br />
<p align="justify"><strong>strlen(string x) - </strong>Retorna o tamanho de uma <strong>string</strong> ignorando o '\0'. O valor de <strong>strlen("casa") </strong>é 4, pois "casa" te 4 caracteres. Se <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_18341ec4b96d60e29c5bf6bdbe42fdbb.gif' style='vertical-align: middle; border: none; ' class='tex' alt="frase" /></span><script type='math/tex'>frase</script> ainda fosse "Alan Turing", então <strong>strlen(frase) </strong>seria 11, pois ela teria 11 caracteres.</p>
<br />
<p align="justify"><strong>strcmp(string a, string b) - </strong>Compara duas <strong>strings</strong>. Se elas forem iguais, a função retorna 0. Se <strong>b </strong>vier antes de <strong>a </strong>em ordem alfabética, ela retorna um valor positivo e retorna um negativo caso contrário. Exemplos: <strong>strcmp("casa","casa")=0</strong>, <strong>strcmp("casa", "arca")=1 </strong>e <strong><strong>strcmp("arca", "casa")=-1.</strong></strong></p>
<br />
<p align="justify">Para que tudo fique mais claro, segue um programa que lê duas palavras de até 100 caracteres na tela e, se elas estiverem em ordem alfabética imprime "estao em ordem alfabetica" e, se não estiverem, imprime "nao estao em ordem alfabetica". Feito isso, se a primeira for menor ou igual que a segunda, imprime, em outra linha, "estao em ordem de tamanho", se não, imprime "nao estao em ordem de tamanho". Se as duas palavras forem iguais, deve imprimir, na saída, unicamente a frase "palavras iguais", e uma quebra de linha ao fim da saída, em qualquer caso:</p>
<style>.gist table { margin-bottom: 0; }</style>
<p align="justify"><script src="https://gist.github.com/rogerioagjr/db255e15be0541a5d36c.js"></script></p>
<p align="justify">Assim como podemos declarar um vetor de inteiros, por exemplo, podemos declarar um vetor de vetores de inteiros, o que chamamos de matriz de inteiros. Se declarássemos, por exemplo, o "<strong>int matriz[10][5];</strong>", teríamos 10 vetores, cada um com 5 inteiros. Para acessarmos o o vetor da posição 4 da matriz, usaríamos o comando "<strong>matriz[4];</strong>", e para acessarmos o elemento da posição 3 deste vetor, faríamos como em qualquer outro vetor e usaríamos o comando "<strong>matriz[4][3];</strong>". Note que os vetores também estão indexados de 0 a 9, e não de 1 a 10. Chamamos essa estrutura de matriz porque é fácil vê-la como uma matriz em que cada linha representa um vetor. Assim, uma matriz <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_6bfb727b656d02ac43818be9f0eb9951.gif' style='vertical-align: middle; border: none; padding-bottom:1px;' class='tex' alt="n \times m" /></span><script type='math/tex'>n \times m</script> representa <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_7b8b965ad4bca0e41ab51de7b31363a1.gif' style='vertical-align: middle; border: none; padding-bottom:2px;' class='tex' alt="n" /></span><script type='math/tex'>n</script> vetores de <span class='MathJax_Preview'><img src='http://noic.com.br/wp-content/plugins/latex/cache/tex_6f8f57715090da2632453988d9a1501b.gif' style='vertical-align: middle; border: none; padding-bottom:2px;' class='tex' alt="m" /></span><script type='math/tex'>m</script> elementos.</p>
<br />
<p align="justify">Imagine o seguinte problema: você recebe <strong>n</strong> strings na entrada, e deve imprimí-las de trás para frente. Este é exatamente o primeiro problema da aula, mas agora, ao invés de guardarmos inteiros em um vetor, deveremos guardar vetores de <strong>char</strong> em um vetor. O nome dessa matriz de <strong>char </strong>será frase. Suponha que são no máximo 110 strings e cada uma tem no máximo 20 caracteres. Então devemos declarar, com sobra, uma matriz de char 110 x 30, com o comando "<strong>char frase[110][30];</strong>". Depois usamos um <strong>for</strong> para ler as <strong>n</strong> strings e salvar cada uma em um dos vetores de <strong>char </strong>da matriz, com o comando: "<strong>for(int i=1; i&lt;=n; i++) scanf(" %s", frase[i]);</strong>". Feito isso, usaremos outro <strong>for</strong>, para percorrermos o vetor de vetores de trás para frente, imprimindo as strings, com o comando: "<strong>for(int i=n; i&gt;0; i--) printf("%s\n", frase[i]);</strong>". A entrada deve ter, na primeira linha, o valor de <strong>n</strong> e, nas próximas <strong>n</strong> linhas, uma string apenas com letras minúsculas. A saída deve ter <strong>n</strong> linhas: as <strong>n</strong> strings de trás para frente. Segue o código:</p>
<style>.gist table { margin-bottom: 0; }</style>
